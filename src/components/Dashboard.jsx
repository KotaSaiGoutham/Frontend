import React, { useState, useEffect, useMemo, useCallback } from "react";
import "./Dashboard.css";
import axios from "axios";
import {
  parse,
  isValid,
  addHours,
  format,
  isWithinInterval,
  startOfDay,
  endOfDay,
  getDay,
  isAfter,
} from "date-fns";
import { Snackbar, Alert as MuiAlert, CircularProgress } from "@mui/material";
import {
  FaSun,
  FaUsers,
  FaUserTie,
  FaCalendarDay,
  FaMoneyBillAlt,
  FaCalendarCheck,
  FaMoon,
  FaBookOpen,
  FaCloudSun,
} from "react-icons/fa";
import {
  getUniqueQuote,
  getInitialShownQuoteIndices,
  saveShownQuoteIndices,
} from "../mockdata/mockdata";
import {
  fetchEmployees,
  fetchStudents,
  fetchUpcomingClasses,
  logoutUser,
  setAuthError,
  saveAutoGeneratedTimetables,
  fetchAutoTimetablesForToday,
} from "../redux/actions";
import { useSelector, useDispatch } from "react-redux";
import { getGreetingInfo } from "../mockdata/function";

const WEATHER_API_KEY = "eb5a71e29d26ddab85144879fe13cd34";
const HYDERABAD_LAT = 17.385;
const HYDERABAD_LON = 78.4867;
const WEATHER_API_URL = `https://api.openweathermap.org/data/2.5/weather?lat=${HYDERABAD_LAT}&lon=${HYDERABAD_LON}&appid=${WEATHER_API_KEY}&units=metric`;

// This hook is also called outside the component, which is incorrect.
// const convertSingleTimeToSlot = useCallback((singleTime) => {
//   // ... code ...
// }, []);

const Dashboard = () => {
  const dispatch = useDispatch();

  const { user } = useSelector((state) => state.auth);

  // CORRECT: Move the useMemo hook inside the component function
  const dayNameToDayNum = useMemo(
    () => ({
      Sunday: 0,
      Monday: 1,
      Tuesday: 2,
      Wednesday: 3,
      Thursday: 4,
      Friday: 5,
      Saturday: 6,
    }),
    []
  );

  // CORRECT: Move the useCallback hook inside the component function
  const convertSingleTimeToSlot = useCallback((singleTime) => {
    if (!singleTime || typeof singleTime !== "string") {
      return null;
    }
    singleTime = singleTime.trim();

    if (singleTime.includes(" to ")) {
      const [start, end] = singleTime.split(" to ");
      if (
        isValid(parse(start.trim(), "hh:mm a", new Date())) &&
        isValid(parse(end.trim(), "hh:mm a", new Date()))
      ) {
        return singleTime;
      }
    }

    try {
      let parsedTime = parse(singleTime, "hh:mm a", new Date());
      if (!isValid(parsedTime)) {
        parsedTime = parse(singleTime, "h:mm a", new Date());
      }
      if (!isValid(parsedTime)) {
        parsedTime = parse(singleTime, "hh:mma", new Date());
      }
      if (!isValid(parsedTime)) {
        parsedTime = parse(singleTime, "h:mma", new Date());
      }
      if (!isValid(parsedTime)) {
        const match = singleTime.match(/(\d+)(am|pm)/i);
        if (match) {
          const hour = parseInt(match[1], 10);
          const ampm = match[2].toLowerCase();
          let tempDate = new Date();
          tempDate.setHours(
            hour +
              (ampm === "pm" && hour !== 12
                ? 12
                : ampm === "am" && hour === 12
                ? -12
                : 0),
            0,
            0,
            0
          );
          parsedTime = tempDate;
        }
      }

      if (isValid(parsedTime)) {
        const endTime = addHours(parsedTime, 1);
        return `${format(parsedTime, "hh:mm a")} to ${format(
          endTime,
          "hh:mm a"
        )}`;
      } else {
        return null;
      }
    } catch (e) {
      return null;
    }
  }, []);

  // ADDED: State for managing the MUI Snackbar
  const [snackbarOpen, setSnackbarOpen] = useState(false);
  const [snackbarMessage, setSnackbarMessage] = useState("");
  const [snackbarSeverity, setSnackbarSeverity] = useState("info");

  const [hasAttemptedAutoGenerateSession, setHasAttemptedAutoGenerateSession] =
    useState(false);
  const [greetingInfo, setGreetingInfo] = useState({
    text: "",
    className: "",
    imageUrl: "",
  });
  const [isGeneratingAuto, setIsGeneratingAuto] = useState(false);
  const [weatherData, setWeatherData] = useState(null);
  const [currentQuote, setCurrentQuote] = useState("");
  const [shownQuoteIndices, setShownQuoteIndices] = useState(
    getInitialShownQuoteIndices
  );
  const [autoGenerateErrorMsg, setAutoGenerateErrorMsg] = useState(null);

  const {
    timetables,
    loading: classesLoading,
    error: classesError,
  } = useSelector((state) => state.classes);
  const {
    students,
    loading: studentsLoading,
    error: studentsError,
  } = useSelector((state) => state.students);
  const {
    employees,
    loading: employeesLoading,
    error: employeesError,
  } = useSelector((state) => state.employees);
  const {
    timetables: autoTimetables,
    loading: autoTimetablesLoading,
    error: autoTimetablesError,
    hasSavedToday: autoTimetablesHasSavedToday,
  } = useSelector((state) => state.autoTimetables);

  const canAccessAll = user?.AllowAll;
  const currentUserSubject = user?.isPhysics
    ? "Physics"
    : user?.isChemistry
    ? "Chemistry"
    : null;
  const currentUserFaculty = user?.name || "Unknown Faculty";

  // ADDED: Helper function to show the MUI Snackbar
  const showSnackbar = useCallback((message, severity) => {
    setSnackbarMessage(message);
    setSnackbarSeverity(severity);
    setSnackbarOpen(true);
  }, []);

  const handleSnackbarClose = (event, reason) => {
    if (reason === "clickaway") {
      return;
    }
    setSnackbarOpen(false);
  };

  const generateTimetablesForStudents = useCallback(async () => {
    if (isGeneratingAuto) {
      return;
    }

    if (
      studentsLoading ||
      classesLoading ||
      autoTimetablesLoading ||
      !user ||
      !user.id ||
      !students ||
      students.length === 0
    ) {
      console.warn("Generation skipped: Data not ready or no user/students.");
      let message = "Generation skipped due to missing data.";
      if (!user || !user.id) {
        message =
          "User data not loaded or not authorized. Cannot auto-generate.";
      } else if (students.length === 0) {
        message = "No students found to generate timetables for.";
      }
      showSnackbar(message, "warning");
      return;
    }

    if (autoTimetablesHasSavedToday) {
      setAutoGenerateErrorMsg(null);
      setIsGeneratingAuto(false);
      showSnackbar(
        "Daily auto-timetables already generated and saved for today.",
        "info"
      );
      return;
    }

    setIsGeneratingAuto(true);
    setAutoGenerateErrorMsg(null);
    const generated = [];
    const now = new Date();
    const startOfToday = startOfDay(now);
    const endOfToday = endOfDay(now);
    const todayDayNum = getDay(now);
    const todayFormatted = format(startOfToday, "yyyy-MM-dd");

    const relevantStudents = students
      .filter(
        (student) =>
          canAccessAll || student.Subject?.trim() === currentUserSubject
      )
      .sort((a, b) => a.Name.localeCompare(b.Name));

    if (relevantStudents.length === 0) {
      setAutoGenerateErrorMsg(
        "No relevant students found for timetable generation based on your permissions."
      );
      setIsGeneratingAuto(false);
      showSnackbar(
        "No relevant students found to auto-generate for.",
        "warning"
      );
      setHasAttemptedAutoGenerateSession(true);
      return;
    }

    const allExistingTimetables = [...timetables, ...autoTimetables];
    const occupiedSlots = new Set();
    allExistingTimetables.forEach((tt) => {
      try {
        const timeStartPart = tt.Time.split(" to ")[0];
        const dateObj = parse(tt.Day, "dd/MM/yyyy", new Date());
        const combinedDateTime = parse(
          `${format(dateObj, "yyyy-MM-dd")} ${timeStartPart}`,
          "yyyy-MM-dd hh:mm a",
          new Date()
        );

        if (isValid(combinedDateTime)) {
          const formattedDateTime = format(
            combinedDateTime,
            "yyyy-MM-dd_hh:mm a"
          );
          occupiedSlots.add(`${formattedDateTime}_${tt.Student}`);
          occupiedSlots.add(`${formattedDateTime}_${tt.Faculty}`);
        } else {
          console.warn(
            `Could not parse existing timetable date/time for clash detection: ${tt.Day} ${tt.Time}`
          );
        }
      } catch (e) {
        console.error(
          "Error processing existing timetable for occupiedSlots:",
          tt,
          e
        );
      }
    });

    relevantStudents.forEach((student) => {
      const studentName = student.Name;
      const studentSubject = student.Subject || currentUserSubject;
      const studentFaculty =
        student.Faculty ||
        (studentSubject === "Physics"
          ? "Dulam"
          : studentSubject === "Chemistry"
          ? "Bollam"
          : currentUserFaculty);

      const preferredSlotsWithDays = (student.classDateandTime || [])
        .map((item) => {
          const parts = item.split("-");
          if (parts.length === 2) {
            const dayOfWeekName = parts[0].trim();
            const timeStr = parts[1].trim();
            const formattedTimeSlot = convertSingleTimeToSlot(timeStr);
            const dayNum = dayNameToDayNum[dayOfWeekName];
            if (formattedTimeSlot && dayNum !== undefined) {
              return {
                dayOfWeekName,
                dayNum,
                formattedTimeSlot,
              };
            }
          }
          return null;
        })
        .filter(Boolean);

      const classesNeeded = parseInt(student.classesPerWeek || 1, 10);
      if (classesNeeded <= 0 || preferredSlotsWithDays.length === 0) {
        return;
      }

      let classesAssigned = 0;
      const candidateSlotsForStudent = [];

      const preferredSlotsForToday = preferredSlotsWithDays.filter(
        (slot) => slot.dayNum === todayDayNum
      );

      for (const preferredSlot of preferredSlotsForToday) {
        const selectedTimeSlot = preferredSlot.formattedTimeSlot;
        const timePartStart = selectedTimeSlot.split(" to ")[0];
        const classStartTimeObj = parse(timePartStart, "hh:mm a", startOfToday);

        const isValidTime = isValid(classStartTimeObj);
        const isWithinToday =
          isValidTime &&
          isWithinInterval(classStartTimeObj, {
            start: startOfToday,
            end: endOfToday,
          });

        if (isValidTime && isWithinToday) {
          candidateSlotsForStudent.push({
            classStartTimeObj: classStartTimeObj,
            formattedTimeSlot: selectedTimeSlot,
            formattedDay: format(classStartTimeObj, "dd/MM/yyyy"),
            isFuture: isAfter(classStartTimeObj, now),
          });
        }
      }

      candidateSlotsForStudent.sort((a, b) => {
        if (a.isFuture && !b.isFuture) return -1;
        if (!a.isFuture && b.isFuture) return 1;
        return a.classStartTimeObj.getTime() - b.classStartTimeObj.getTime();
      });

      for (let i = 0; i < candidateSlotsForStudent.length; i++) {
        const candidate = candidateSlotsForStudent[i];
        if (classesAssigned >= classesNeeded) {
          break;
        }

        const studentSlotKey = `${format(
          candidate.classStartTimeObj,
          "yyyy-MM-dd_hh:mm a"
        )}_${studentName}`;
        const facultySlotKey = `${format(
          candidate.classStartTimeObj,
          "yyyy-MM-dd_hh:mm a"
        )}_${studentFaculty}`;

        if (
          !occupiedSlots.has(studentSlotKey) &&
          !occupiedSlots.has(facultySlotKey)
        ) {
          generated.push({
            Student: studentName,
            Topic: "",
            Day: candidate.formattedDay,
            Faculty: studentFaculty,
            Subject: studentSubject,
            Time: candidate.formattedTimeSlot,
          });

          occupiedSlots.add(studentSlotKey);
          occupiedSlots.add(facultySlotKey);
          classesAssigned++;
        }
      }
    });

    if (generated.length > 0) {
      const finalGeneratedItems = generated.map((item) => ({
        ...item,
        userId: user.id,
        generationDate: todayFormatted,
      }));
      try {
        await dispatch(saveAutoGeneratedTimetables(finalGeneratedItems));
        showSnackbar(
          `Successfully generated and saved ${finalGeneratedItems.length} timetables for today!`,
          "success"
        );
      } catch (error) {
        setAutoGenerateErrorMsg(
          `Failed to save auto-generated timetables: ${error.message}`
        );
        showSnackbar(
          `Failed to save auto-generated timetables: ${error.message}`,
          "error"
        );
      }
    } else {
      showSnackbar(
        "No new timetables could be auto-generated for today.",
        "info"
      );
    }

    setHasAttemptedAutoGenerateSession(true);
    setIsGeneratingAuto(false);
  }, [
    students,
    user,
    studentsLoading,
    classesLoading,
    autoTimetablesLoading,
    autoTimetablesHasSavedToday,
    timetables,
    autoTimetables,
    dispatch,
    convertSingleTimeToSlot,
    isGeneratingAuto,
    showSnackbar,
    canAccessAll,
    currentUserSubject,
    currentUserFaculty,
    dayNameToDayNum, // ADDED: dayNameToDayNum to dependencies
  ]);

  useEffect(() => {
    if (
      !user ||
      !user.id ||
      studentsLoading ||
      classesLoading ||
      !students ||
      students.length === 0
    ) {
      return;
    }

    if (autoTimetablesLoading) {
      return;
    }

    if (autoTimetablesHasSavedToday || hasAttemptedAutoGenerateSession) {
      return;
    }

    setHasAttemptedAutoGenerateSession(true);
    generateTimetablesForStudents();
  }, [
    dispatch,
    user,
    students,
    studentsLoading,
    classesLoading,
    autoTimetablesLoading,
    autoTimetablesHasSavedToday,
    hasAttemptedAutoGenerateSession,
    generateTimetablesForStudents,
  ]);

  useEffect(() => {
    const updateAndSaveQuote = () => {
      setShownQuoteIndices((prevIndices) => {
        const { quote, newShownIndices } = getUniqueQuote(prevIndices);
        setCurrentQuote(quote);
        saveShownQuoteIndices(newShownIndices);
        return newShownIndices;
      });
    };

    setGreetingInfo(getGreetingInfo());
    updateAndSaveQuote();
    const interval = setInterval(() => {
      setGreetingInfo(getGreetingInfo());
      updateAndSaveQuote();
    }, 24 * 60 * 60 * 1000);

    return () => clearInterval(interval);
  }, []);

  useEffect(() => {
    const fetchWeather = async () => {
      try {
        const response = await axios.get(WEATHER_API_URL);
        setWeatherData(response.data);
      } catch (error) {
        console.error("Error fetching weather data:", error);
        setWeatherData(null);
      }
    };
    fetchWeather();
    const weatherInterval = setInterval(fetchWeather, 15 * 60 * 1000);
    return () => clearInterval(weatherInterval);
  }, []);

  useEffect(() => {
    const token = localStorage.getItem("token");
    if (!token) {
      console.warn("No authentication token found. Redirecting to login.");
      dispatch(logoutUser());
      dispatch(setAuthError("No authentication token found. Please log in."));
      return;
    }
    dispatch(fetchAutoTimetablesForToday(user?.id));
    dispatch(fetchStudents());
    dispatch(fetchEmployees());
    dispatch(fetchUpcomingClasses());
  }, [dispatch, user]);

  let filteredStudents = [];
  if (students && students.length > 0 && user) {
    if (user.AllowAll) {
      filteredStudents = students;
    } else if (user.isPhysics) {
      filteredStudents = students.filter(
        (student) => student.Subject === "Physics"
      );
    } else if (user.isChemistry) {
      filteredStudents = students.filter(
        (student) => student.Subject === "Chemistry"
      );
    } else {
      filteredStudents = [];
      console.warn(
        "User has no specific subject permissions (isPhysics, isChemistry) and not AllowAll. Displaying no students."
      );
    }
  }

  // ... (previous code remains the same)

  // Combine both timetables and autoTimetables into a single array
  const allTimetables = [...(timetables || []), ...(autoTimetables || [])];

  let filteredTimetables = [];
  if (allTimetables.length > 0 && user) {
    let permissionFilteredTimetables = [];

    // Filter timetables based on user permissions
    if (user.AllowAll) {
      permissionFilteredTimetables = allTimetables;
    } else if (user.isPhysics) {
      permissionFilteredTimetables = allTimetables.filter(
        (schedule) => schedule.Subject === "Physics"
      );
    } else if (user.isChemistry) {
      permissionFilteredTimetables = allTimetables.filter(
        (schedule) => schedule.Subject === "Chemistry"
      );
    } else {
      permissionFilteredTimetables = [];
      console.warn(
        "User has no specific subject permissions for timetables. Displaying no classes."
      );
    }

    // Filter out classes that have already passed
    const now = new Date();
    filteredTimetables = permissionFilteredTimetables.filter((schedule) => {
      try {
        const classStartTimeStr = schedule.Time.split(" to ")[0];
        const classDateTime = parse(
          `${schedule.Day} ${classStartTimeStr}`,
          "dd/MM/yyyy hh:mm a",
          new Date()
        );
        // Return true if the class date/time is in the future
        return isValid(classDateTime) && isAfter(classDateTime, now);
      } catch (e) {
        console.error("Error parsing timetable date/time:", schedule, e);
        return false; // Exclude invalid entries
      }
    });

    // Sort the remaining classes chronologically
    filteredTimetables.sort((a, b) => {
      const dateA = parse(
        `${a.Day} ${a.Time.split(" to ")[0]}`,
        "dd/MM/yyyy hh:mm a",
        new Date()
      );
      const dateB = parse(
        `${b.Day} ${b.Time.split(" to ")[0]}`,
        "dd/MM/yyyy hh:mm a",
        new Date()
      );

      if (isValid(dateA) && isValid(dateB)) {
        return dateA.getTime() - dateB.getTime();
      }
      return 0; // Maintain order if dates are invalid
    });
  }

  // ... (rest of the component remains the same)

  const totalStudents = filteredStudents.length;
  const totalEmployees = employees.length;
  const totalFeeCollection = filteredStudents.reduce((sum, student) => {
    const paymentStatus = student["Payment Status"];
    const monthlyFee =
      typeof student.monthlyFee === "number"
        ? student.monthlyFee
        : parseFloat(student["Monthly Fee"]);

    if (paymentStatus === "Paid" && !isNaN(monthlyFee)) {
      return sum + monthlyFee;
    }
    return sum;
  }, 0);

  if (students.loading) {
    return (
      <div className="dashboard-loading">
        <CircularProgress />
        <p>Loading Dashboard Data...</p>
      </div>
    );
  }
  const firstName = user && user.name ? user.name.split(" ")[0] : "Guest";

const { demoClasses } = useSelector((state) => state.demoClasses);

// Assume these state variables and data are available in your component
// const [demoClasses, setDemoClasses] = useState([]); // Fetched from Redux or API
// const [syllabusData, setSyllabusData] = useState([]); // Derived from filteredStudents
// const [demoStatusCounts, setDemoStatusCounts] = useState({}); // Derived from demoClasses

// ... (other component logic and useEffects)

return (
  <div className="dashboard-container">
    <Snackbar
      open={snackbarOpen}
      autoHideDuration={6000}
      onClose={handleSnackbarClose}
      anchorOrigin={{ vertical: "bottom", horizontal: "right" }}
    >
      <MuiAlert
        onClose={handleSnackbarClose}
        severity={snackbarSeverity}
        sx={{ width: "100%" }}
      >
        {snackbarMessage}
      </MuiAlert>
    </Snackbar>

    <div
      className={`dashboard-card dashboard-header ${greetingInfo.className}`}
      style={{
        backgroundImage: `url(${greetingInfo.imageUrl})`,
      }}
    >
      <div className="background-overlay"></div>
      <div className="greeting-content">
        <h1>
          Good {greetingInfo.text}, {firstName}!
        </h1>
        <p className="welcome-message">
          Welcome to your Electron Academy Dashboard.
        </p>
        {currentQuote && (
          <p className="motivational-quote">"{currentQuote}"</p>
        )}
      </div>
      <div className="greeting-graphic">
        {greetingInfo.className === "morning" && (
          <FaSun className="greeting-icon" />
        )}
        {greetingInfo.className === "afternoon" && (
          <FaBookOpen className="greeting-icon" />
        )}
        {greetingInfo.className === "evening" && (
          <FaMoon className="greeting-icon" />
        )}
        {weatherData && (
          <p className="weather-info weather-right">
            <FaCloudSun className="weather-icon" /> {weatherData.name}:{" "}
            {weatherData.main.temp.toFixed(1)}°C
          </p>
        )}
      </div>
    </div>

    {/* Section 1: Key Performance Indicators (KPIs) */}
    <div className="metrics-grid">
      <div className="dashboard-card metric-card fade-in-up">
        <div className="metric-icon">
          <FaUsers />
        </div>
        <div className="metric-info">
          <p className="metric-label">Total Students</p>
          <p className="metric-value">{totalStudents}</p>
        </div>
      </div>

      <div className="dashboard-card metric-card fade-in-up delay-1">
        <div className="metric-icon">
          <FaUserTie />
        </div>
        <div className="metric-info">
          <p className="metric-label">Total Employees</p>
          <p className="metric-value">{totalEmployees}</p>
        </div>
      </div>

      <div className="dashboard-card metric-card fade-in-up delay-2">
        <div className="metric-icon">
          <FaCalendarDay />
        </div>
        <div className="metric-info">
          <p className="metric-label">Upcoming Classes</p>
          <p className="metric-value">{filteredTimetables?.length}</p>
        </div>
      </div>

      <div className="dashboard-card metric-card fade-in-up delay-3">
        <div className="metric-icon">
          <FaMoneyBillAlt />
        </div>
        <div className="metric-info">
          <p className="metric-label">Monthly Fee Collection</p>
          <p className="metric-value">₹{totalFeeCollection.toLocaleString()}</p>
        </div>
      </div>
    </div>

    {/* Section 2: Core Dashboard Content */}
    <div className="main-content-grid-extended">

      {/* Upcoming Classes Section */}
      <div className="dashboard-card upcoming-classes-card fade-in-up delay-4">
        <h2>
          <FaCalendarCheck className="card-icon" /> Upcoming Classes
        </h2>
        {filteredTimetables?.length > 0 ? (
          <div className="upcoming-classes-list">
            {filteredTimetables.map((cls, index) => (
              <div
                key={cls.id || index}
                className={`upcoming-class-item ${
                  index === 0 ? "highlighted" : ""
                }`}
              >
                <div className="class-time-info">
                  <p className="class-date">{cls.Day}</p>
                  <p className="class-time">{cls.Time}</p>
                </div>
                <div className="class-details">
                  <p className="class-student">{cls.Student}</p>
                  <p className="class-subject-topic">
                    {cls.Subject} - {cls.Topic || "No Topic"}
                  </p>
                </div>
              </div>
            ))}
          </div>
        ) : (
          <p className="no-data-message">No upcoming classes scheduled.</p>
        )}
      </div>

      {/* Demo Class Insights Section */}
      <div className="dashboard-card demo-classes-card fade-in-up delay-5">
        <h2>
          <FaBookOpen className="card-icon" /> Demo Classes
        </h2>
        <div className="democlass-visuals">
          {/* Bar Graph for Demo Status (Placeholder) */}
          <div className="democlass-bar-graph">
            <p>Demo Status Breakdown</p>
            {/* Example: Replace with an actual chart library component like Chart.js or Recharts */}
            <div className="chart-container">
              <div className="bar-wrapper">
                <div className="bar success-bar" style={{ height: '50px' }}></div>
                <span>Success</span>
              </div>
              <div className="bar scheduled-bar" style={{ height: '30px' }}></div>
              <span>Scheduled</span>
            </div>
          </div>
          {/* Recent Demo Classes List */}
          <div className="recent-demo-list">
            <h3>Recent Demos</h3>
            {/* You'll need to fetch and filter your demoClasses data */}
            {demoClasses?.length > 0 ? (
              demoClasses.slice(0, 3).map((demo, index) => (
                <div key={demo.id || index} className="recent-demo-item">
                  <p className="demo-student-name">{demo.studentName}</p>
                  <span className={`status-badge status-${demo.status.toLowerCase()}`}>
                    {demo.status}
                  </span>
                </div>
              ))
            ) : (
              <p>No recent demos.</p>
            )}
          </div>
        </div>
      </div>
      
      {/* Student Progress & Performance Section */}
      <div className="dashboard-card student-progress-card fade-in-up delay-6">
        <h2>
          <FaUsers className="card-icon" /> Student Insights
        </h2>
        <div className="student-progress-visuals">
          {/* Syllabus Progress Bar (Placeholder) */}
          <div className="syllabus-progress-graph">
            <p>Syllabus Progress by Subject</p>
            {/* Example: Replace with an actual chart library component */}
            <div className="chart-container">
              <div className="progress-item">
                <span>Physics</span>
                <div className="progress-bar-container">
                  <div className="progress-bar" style={{ width: '70%' }}></div>
                </div>
                <span>70%</span>
              </div>
              <div className="progress-item">
                <span>Chemistry</span>
                <div className="progress-bar-container">
                  <div className="progress-bar" style={{ width: '45%' }}></div>
                </div>
                <span>45%</span>
              </div>
            </div>
          </div>
        </div>
        {/* Latest Student Activity List */}
        <div className="latest-activity-list">
            <h3>Latest Student Activity</h3>
            {filteredStudents?.slice(0, 5).map((student, index) => (
                <div key={student.id || index} className="activity-item">
                    <p className="activity-student-name">{student.Name}</p>
                    <p className="activity-details">
                        {student.classesCompleted} classes completed ({student.classesCompleted} total)
                    </p>
                </div>
            ))}
        </div>
      </div>

    </div>
  </div>
);
};

export default Dashboard;
