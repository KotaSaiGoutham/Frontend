import React, { useState, useEffect, useMemo, useCallback } from "react";
import "./Dashboard.css";
import axios from "axios";
import {
  parse,
  isValid,
  addHours,
  format,
  isWithinInterval,
  startOfDay,
  endOfDay,
  getDay,
  isAfter,
} from "date-fns";
import { Snackbar, Alert as MuiAlert, CircularProgress } from "@mui/material";
import {
  FaSun,
  FaUsers,
  FaUserTie,
  FaCalendarDay,
  FaMoneyBillAlt,
  FaCalendarCheck,
  FaMoon,
  FaBookOpen,
  FaCloudSun,
  FaRupeeSign,
  FaCheckCircle,
  FaClock,
  FaClipboardList,
  FaUserGraduate,
  FaUserClock,
  FaHourglassHalf,
  FaTimesCircle,
} from "react-icons/fa";
import {
  getUniqueQuote,
  getInitialShownQuoteIndices,
  saveShownQuoteIndices,
} from "../mockdata/mockdata";
import {
  fetchEmployees,
  fetchStudents,
  fetchUpcomingClasses,
  logoutUser,
  setAuthError,
  saveAutoGeneratedTimetables,
  fetchAutoTimetablesForToday,
  fetchDemoClasses,
} from "../redux/actions";
import { useSelector, useDispatch } from "react-redux";
import {
  getGreetingInfo,
  getRecentEmployeeActivity,
  getRecentStudentActivity,
} from "../mockdata/function";
const Dashboard = () => {
  const dispatch = useDispatch();
  const { user } = useSelector((state) => state.auth);

  const dayNameToDayNum = useMemo(
    () => ({
      Sunday: 0,
      Monday: 1,
      Tuesday: 2,
      Wednesday: 3,
      Thursday: 4,
      Friday: 5,
      Saturday: 6,
    }),
    []
  );
  const convertSingleTimeToSlot = useCallback((singleTime) => {
    if (!singleTime || typeof singleTime !== "string") {
      return null;
    }
    singleTime = singleTime.trim();

    if (singleTime.includes(" to ")) {
      const [start, end] = singleTime.split(" to ");
      if (
        isValid(parse(start.trim(), "hh:mm a", new Date())) &&
        isValid(parse(end.trim(), "hh:mm a", new Date()))
      ) {
        return singleTime;
      }
    }

    try {
      let parsedTime = parse(singleTime, "hh:mm a", new Date());
      if (!isValid(parsedTime)) {
        parsedTime = parse(singleTime, "h:mm a", new Date());
      }
      if (!isValid(parsedTime)) {
        parsedTime = parse(singleTime, "hh:mma", new Date());
      }
      if (!isValid(parsedTime)) {
        parsedTime = parse(singleTime, "h:mma", new Date());
      }
      if (!isValid(parsedTime)) {
        const match = singleTime.match(/(\d+)(am|pm)/i);
        if (match) {
          const hour = parseInt(match[1], 10);
          const ampm = match[2].toLowerCase();
          let tempDate = new Date();
          tempDate.setHours(
            hour +
              (ampm === "pm" && hour !== 12
                ? 12
                : ampm === "am" && hour === 12
                ? -12
                : 0),
            0,
            0,
            0
          );
          parsedTime = tempDate;
        }
      }

      if (isValid(parsedTime)) {
        const endTime = addHours(parsedTime, 1);
        return `${format(parsedTime, "hh:mm a")} to ${format(
          endTime,
          "hh:mm a"
        )}`;
      } else {
        return null;
      }
    } catch (e) {
      return null;
    }
  }, []);

  const [snackbarOpen, setSnackbarOpen] = useState(false);
  const [snackbarMessage, setSnackbarMessage] = useState("");
  const [snackbarSeverity, setSnackbarSeverity] = useState("info");

  const [hasAttemptedAutoGenerateSession, setHasAttemptedAutoGenerateSession] =
    useState(false);
  const [greetingInfo, setGreetingInfo] = useState({
    text: "",
    className: "",
    imageUrl: "",
  });
  const [isGeneratingAuto, setIsGeneratingAuto] = useState(false);
  const [currentQuote, setCurrentQuote] = useState("");
  const [shownQuoteIndices, setShownQuoteIndices] = useState(
    getInitialShownQuoteIndices
  );
  const [autoGenerateErrorMsg, setAutoGenerateErrorMsg] = useState(null);

  const {
    timetables,
    loading: classesLoading,
    error: classesError,
  } = useSelector((state) => state.classes);
  const {
    students,
    loading: studentsLoading,
    error: studentsError,
  } = useSelector((state) => state.students);
  const {
    employees,
    loading: employeesLoading,
    error: employeesError,
  } = useSelector((state) => state.employees);
  const {
    timetables: autoTimetables,
    loading: autoTimetablesLoading,
    error: autoTimetablesError,
    hasSavedToday: autoTimetablesHasSavedToday,
  } = useSelector((state) => state.autoTimetables);

  const canAccessAll = user?.AllowAll;
  const currentUserSubject = user?.isPhysics
    ? "Physics"
    : user?.isChemistry
    ? "Chemistry"
    : null;
  const currentUserFaculty = user?.name || "Unknown Faculty";
  const processedStudentActivity = getRecentStudentActivity(students);
  const processedEmployeeActivity = getRecentEmployeeActivity(employees);
  console.log("processedStudentActivity", processedStudentActivity);
  // ADDED: Helper function to show the MUI Snackbar
  const showSnackbar = useCallback((message, severity) => {
    setSnackbarMessage(message);
    setSnackbarSeverity(severity);
    setSnackbarOpen(true);
  }, []);

  const handleSnackbarClose = (event, reason) => {
    if (reason === "clickaway") {
      return;
    }
    setSnackbarOpen(false);
  };

  const generateTimetablesForStudents = useCallback(async () => {
    if (isGeneratingAuto) {
      return;
    }

    if (
      studentsLoading ||
      classesLoading ||
      autoTimetablesLoading ||
      !user ||
      !user.id ||
      !students ||
      students.length === 0
    ) {
      console.warn("Generation skipped: Data not ready or no user/students.");
      let message = "Generation skipped due to missing data.";
      if (!user || !user.id) {
        message =
          "User data not loaded or not authorized. Cannot auto-generate.";
      } else if (students.length === 0) {
        message = "No students found to generate timetables for.";
      }
      showSnackbar(message, "warning");
      return;
    }

    if (autoTimetablesHasSavedToday) {
      setAutoGenerateErrorMsg(null);
      setIsGeneratingAuto(false);
      showSnackbar(
        "Daily auto-timetables already generated and saved for today.",
        "info"
      );
      return;
    }

    setIsGeneratingAuto(true);
    setAutoGenerateErrorMsg(null);
    const generated = [];
    const now = new Date();
    const startOfToday = startOfDay(now);
    const endOfToday = endOfDay(now);
    const todayDayNum = getDay(now);
    const todayFormatted = format(startOfToday, "yyyy-MM-dd");

    const relevantStudents = students
      .filter(
        (student) =>
          canAccessAll || student.Subject?.trim() === currentUserSubject
      )
      .sort((a, b) => a.Name.localeCompare(b.Name));

    if (relevantStudents.length === 0) {
      setAutoGenerateErrorMsg(
        "No relevant students found for timetable generation based on your permissions."
      );
      setIsGeneratingAuto(false);
      showSnackbar(
        "No relevant students found to auto-generate for.",
        "warning"
      );
      setHasAttemptedAutoGenerateSession(true);
      return;
    }

    const allExistingTimetables = [...timetables, ...autoTimetables];
    const occupiedSlots = new Set();
    allExistingTimetables.forEach((tt) => {
      try {
        const timeStartPart = tt.Time.split(" to ")[0];
        const dateObj = parse(tt.Day, "dd/MM/yyyy", new Date());
        const combinedDateTime = parse(
          `${format(dateObj, "yyyy-MM-dd")} ${timeStartPart}`,
          "yyyy-MM-dd hh:mm a",
          new Date()
        );

        if (isValid(combinedDateTime)) {
          const formattedDateTime = format(
            combinedDateTime,
            "yyyy-MM-dd_hh:mm a"
          );
          occupiedSlots.add(`${formattedDateTime}_${tt.Student}`);
          occupiedSlots.add(`${formattedDateTime}_${tt.Faculty}`);
        } else {
          console.warn(
            `Could not parse existing timetable date/time for clash detection: ${tt.Day} ${tt.Time}`
          );
        }
      } catch (e) {
        console.error(
          "Error processing existing timetable for occupiedSlots:",
          tt,
          e
        );
      }
    });

    relevantStudents.forEach((student) => {
      const studentName = student.Name;
      const studentSubject = student.Subject || currentUserSubject;
      const studentFaculty =
        student.Faculty ||
        (studentSubject === "Physics"
          ? "Dulam"
          : studentSubject === "Chemistry"
          ? "Bollam"
          : currentUserFaculty);

      const preferredSlotsWithDays = (student.classDateandTime || [])
        .map((item) => {
          const parts = item.split("-");
          if (parts.length === 2) {
            const dayOfWeekName = parts[0].trim();
            const timeStr = parts[1].trim();
            const formattedTimeSlot = convertSingleTimeToSlot(timeStr);
            const dayNum = dayNameToDayNum[dayOfWeekName];
            if (formattedTimeSlot && dayNum !== undefined) {
              return {
                dayOfWeekName,
                dayNum,
                formattedTimeSlot,
              };
            }
          }
          return null;
        })
        .filter(Boolean);

      const classesNeeded = parseInt(student.classesPerWeek || 1, 10);
      if (classesNeeded <= 0 || preferredSlotsWithDays.length === 0) {
        return;
      }

      let classesAssigned = 0;
      const candidateSlotsForStudent = [];

      const preferredSlotsForToday = preferredSlotsWithDays.filter(
        (slot) => slot.dayNum === todayDayNum
      );

      for (const preferredSlot of preferredSlotsForToday) {
        const selectedTimeSlot = preferredSlot.formattedTimeSlot;
        const timePartStart = selectedTimeSlot.split(" to ")[0];
        const classStartTimeObj = parse(timePartStart, "hh:mm a", startOfToday);

        const isValidTime = isValid(classStartTimeObj);
        const isWithinToday =
          isValidTime &&
          isWithinInterval(classStartTimeObj, {
            start: startOfToday,
            end: endOfToday,
          });

        if (isValidTime && isWithinToday) {
          candidateSlotsForStudent.push({
            classStartTimeObj: classStartTimeObj,
            formattedTimeSlot: selectedTimeSlot,
            formattedDay: format(classStartTimeObj, "dd/MM/yyyy"),
            isFuture: isAfter(classStartTimeObj, now),
          });
        }
      }

      candidateSlotsForStudent.sort((a, b) => {
        if (a.isFuture && !b.isFuture) return -1;
        if (!a.isFuture && b.isFuture) return 1;
        return a.classStartTimeObj.getTime() - b.classStartTimeObj.getTime();
      });

      for (let i = 0; i < candidateSlotsForStudent.length; i++) {
        const candidate = candidateSlotsForStudent[i];
        if (classesAssigned >= classesNeeded) {
          break;
        }

        const studentSlotKey = `${format(
          candidate.classStartTimeObj,
          "yyyy-MM-dd_hh:mm a"
        )}_${studentName}`;
        const facultySlotKey = `${format(
          candidate.classStartTimeObj,
          "yyyy-MM-dd_hh:mm a"
        )}_${studentFaculty}`;

        if (
          !occupiedSlots.has(studentSlotKey) &&
          !occupiedSlots.has(facultySlotKey)
        ) {
          generated.push({
            Student: studentName,
            Topic: "",
            Day: candidate.formattedDay,
            Faculty: studentFaculty,
            Subject: studentSubject,
            Time: candidate.formattedTimeSlot,
          });

          occupiedSlots.add(studentSlotKey);
          occupiedSlots.add(facultySlotKey);
          classesAssigned++;
        }
      }
    });

    if (generated.length > 0) {
      const finalGeneratedItems = generated.map((item) => ({
        ...item,
        userId: user.id,
        generationDate: todayFormatted,
      }));
      try {
        await dispatch(saveAutoGeneratedTimetables(finalGeneratedItems));
        showSnackbar(
          `Successfully generated and saved ${finalGeneratedItems.length} timetables for today!`,
          "success"
        );
      } catch (error) {
        setAutoGenerateErrorMsg(
          `Failed to save auto-generated timetables: ${error.message}`
        );
        showSnackbar(
          `Failed to save auto-generated timetables: ${error.message}`,
          "error"
        );
      }
    } else {
      showSnackbar(
        "No new timetables could be auto-generated for today.",
        "info"
      );
    }

    setHasAttemptedAutoGenerateSession(true);
    setIsGeneratingAuto(false);
  }, [
    students,
    user,
    studentsLoading,
    classesLoading,
    autoTimetablesLoading,
    autoTimetablesHasSavedToday,
    timetables,
    autoTimetables,
    dispatch,
    convertSingleTimeToSlot,
    isGeneratingAuto,
    showSnackbar,
    canAccessAll,
    currentUserSubject,
    currentUserFaculty,
    dayNameToDayNum,
  ]);

  useEffect(() => {
    if (
      !user ||
      !user.id ||
      studentsLoading ||
      classesLoading ||
      !students ||
      students.length === 0
    ) {
      return;
    }

    if (autoTimetablesLoading) {
      return;
    }

    if (autoTimetablesHasSavedToday || hasAttemptedAutoGenerateSession) {
      return;
    }

    setHasAttemptedAutoGenerateSession(true);
    generateTimetablesForStudents();
  }, [
    dispatch,
    user,
    students,
    studentsLoading,
    classesLoading,
    autoTimetablesLoading,
    autoTimetablesHasSavedToday,
    hasAttemptedAutoGenerateSession,
    generateTimetablesForStudents,
  ]);

  useEffect(() => {
    const updateAndSaveQuote = () => {
      setShownQuoteIndices((prevIndices) => {
        const { quote, newShownIndices } = getUniqueQuote(prevIndices);
        setCurrentQuote(quote);
        saveShownQuoteIndices(newShownIndices);
        return newShownIndices;
      });
    };

    setGreetingInfo(getGreetingInfo());
    updateAndSaveQuote();
    const interval = setInterval(() => {
      setGreetingInfo(getGreetingInfo());
      updateAndSaveQuote();
    }, 24 * 60 * 60 * 1000);

    return () => clearInterval(interval);
  }, []);

  useEffect(() => {
    const token = localStorage.getItem("token");
    if (!token) {
      console.warn("No authentication token found. Redirecting to login.");
      dispatch(logoutUser());
      dispatch(setAuthError("No authentication token found. Please log in."));
      return;
    }
    dispatch(fetchAutoTimetablesForToday(user?.id));
    dispatch(fetchStudents());
    dispatch(fetchEmployees());
    dispatch(fetchUpcomingClasses());
    dispatch(fetchDemoClasses());
  }, [dispatch, user]);

  let filteredStudents = [];
  if (students && students.length > 0 && user) {
    if (user.AllowAll) {
      filteredStudents = students;
    } else if (user.isPhysics) {
      filteredStudents = students.filter(
        (student) => student.Subject === "Physics"
      );
    } else if (user.isChemistry) {
      filteredStudents = students.filter(
        (student) => student.Subject === "Chemistry"
      );
    } else {
      filteredStudents = [];
      console.warn(
        "User has no specific subject permissions (isPhysics, isChemistry) and not AllowAll. Displaying no students."
      );
    }
    filteredStudents = filteredStudents.filter(
      (student) => student.isActive === true
    );
  }
  const allTimetables = [...(timetables || []), ...(autoTimetables || [])];

  let filteredTimetables = [];
  if (allTimetables.length > 0 && user) {
    let permissionFilteredTimetables = [];

    if (user.AllowAll) {
      permissionFilteredTimetables = allTimetables;
    } else if (user.isPhysics) {
      permissionFilteredTimetables = allTimetables.filter(
        (schedule) => schedule.Subject === "Physics"
      );
    } else if (user.isChemistry) {
      permissionFilteredTimetables = allTimetables.filter(
        (schedule) => schedule.Subject === "Chemistry"
      );
    } else {
      permissionFilteredTimetables = [];
      console.warn(
        "User has no specific subject permissions for timetables. Displaying no classes."
      );
    }

    const now = new Date();
    filteredTimetables = permissionFilteredTimetables.filter((schedule) => {
      try {
        const classStartTimeStr = schedule.Time.split(" to ")[0];
        const classDateTime = parse(
          `${schedule.Day} ${classStartTimeStr}`,
          "dd/MM/yyyy hh:mm a",
          new Date()
        );
        return isValid(classDateTime) && isAfter(classDateTime, now);
      } catch (e) {
        console.error("Error parsing timetable date/time:", schedule, e);
        return false;
      }
    });

    filteredTimetables.sort((a, b) => {
      const dateA = parse(
        `${a.Day} ${a.Time.split(" to ")[0]}`,
        "dd/MM/yyyy hh:mm a",
        new Date()
      );
      const dateB = parse(
        `${b.Day} ${b.Time.split(" to ")[0]}`,
        "dd/MM/yyyy hh:mm a",
        new Date()
      );

      if (isValid(dateA) && isValid(dateB)) {
        return dateA.getTime() - dateB.getTime();
      }
      return 0;
    });
  }
  const totalStudents = filteredStudents.length;
  const totalEmployees = employees.length;
  const totalFeeCollection = filteredStudents.reduce((sum, student) => {
    const paymentStatus = student["Payment Status"];
    const monthlyFee =
      typeof student.monthlyFee === "number"
        ? student.monthlyFee
        : parseFloat(student["Monthly Fee"]);

    if (paymentStatus === "Paid" && !isNaN(monthlyFee)) {
      return sum + monthlyFee;
    }
    return sum;
  }, 0);

  if (students.loading) {
    return (
      <div className="dashboard-loading">
        <CircularProgress />
        <p>Loading Dashboard Data...</p>
      </div>
    );
  }
  const { demoClasses, loading, error } = useSelector(
    (state) => state.demoClasses
  );
  const firstName = user && user.name ? user.name.split(" ")[0] : "Guest";
  const userHasSubjectPreference = user.isPhysics || user.isChemistry;

  const filteredDemoClasses = userHasSubjectPreference
    ? demoClasses?.filter((demo) => {
        const demoSubject = demo.Subject?.toLowerCase();
        return (
          (user.isPhysics && demoSubject === "physics") ||
          (user.isChemistry && demoSubject === "chemistry") ||
          (user.isMaths && demoSubject === "maths")
        );
      })
    : demoClasses;

  const getDemoClassMetrics = (demos) => {
    if (!demos)
      return {
        successCount: 0,
        scheduledCount: 0,
        pendingCount: 0,
        failureCount: 0,
        total: 0,
      };

    const successCount = demos.filter(
      (d) => d.status?.toLowerCase() === "success"
    ).length;
    const scheduledCount = demos.filter(
      (d) => d.status?.toLowerCase() === "scheduled"
    ).length;
    const pendingCount = demos.filter(
      (d) => d.status?.toLowerCase() === "pending"
    ).length;
    const failureCount = demos.filter(
      (d) => d.status?.toLowerCase() === "failure"
    ).length;

    const total = demos.length;
    return { successCount, scheduledCount, pendingCount, failureCount, total };
  };

  const demoMetrics = getDemoClassMetrics(filteredDemoClasses);

  return (
    <div className="dashboard-container">
      {/* Snackbar for alerts */}
      <Snackbar
        open={snackbarOpen}
        autoHideDuration={6000}
        onClose={handleSnackbarClose}
        anchorOrigin={{ vertical: "top", horizontal: "right" }}
      >
        <MuiAlert
          onClose={handleSnackbarClose}
          severity={snackbarSeverity}
          sx={{ width: "100%" }}
        >
          {snackbarMessage}
        </MuiAlert>
      </Snackbar>

      {/* Greeting Header */}
      <div
        className={`dashboard-card dashboard-header ${greetingInfo.className}`}
      >
        <div
          className="header-background-graphic"
          style={{ backgroundImage: `url(${greetingInfo.imageUrl})` }}
        >
          <div className="background-overlay"></div>
        </div>
        <div className="header-content-wrapper">
          <div className="greeting-content">
            <h1 className="greeting-heading">
              Good {greetingInfo.text}, {firstName}!
            </h1>
            <p className="welcome-message">
              Welcome to your Electron Academy Dashboard.
            </p>
            {currentQuote && (
              <p className="motivational-quote">"{currentQuote}"</p>
            )}
          </div>
          <div className="greeting-graphic">
            {greetingInfo.className === "morning" && (
              <FaSun className="greeting-icon" />
            )}
            {greetingInfo.className === "afternoon" && (
              <FaBookOpen className="greeting-icon" />
            )}
            {greetingInfo.className === "evening" && (
              <FaMoon className="greeting-icon" />
            )}
          </div>
        </div>
      </div>

      {/* Key Metrics Grid */}
      <div className="metrics-grid">
        <div className="dashboard-card metric-card fade-in-up">
          <div className="metric-icon metric-icon-student">
            <FaUsers />
          </div>
          <div className="metric-info">
            <p className="metric-label">Total Students (Active)</p>
            <p className="metric-value">{totalStudents}</p>
          </div>
        </div>

        <div className="dashboard-card metric-card fade-in-up delay-1">
          <div className="metric-icon metric-icon-employee">
            <FaUserTie />
          </div>
          <div className="metric-info">
            <p className="metric-label">Total Employees</p>
            <p className="metric-value">{totalEmployees}</p>
          </div>
        </div>

        <div className="dashboard-card metric-card fade-in-up delay-2">
          <div className="metric-icon metric-icon-classes">
            <FaCalendarDay />
          </div>
          <div className="metric-info">
            <p className="metric-label">Upcoming Classes</p>
            <p className="metric-value">{filteredTimetables?.length}</p>
          </div>
        </div>

        <div className="dashboard-card metric-card fade-in-up delay-3">
          <div className="metric-icon metric-icon-fee">
            <FaRupeeSign />
          </div>
          <div className="metric-info">
            <p className="metric-label">Monthly Fee Collection</p>
            <p className="metric-value">
              ₹{totalFeeCollection?.toLocaleString()}
            </p>
          </div>
        </div>
      </div>

      {/* Main Content Grid with 4 Sections */}
      <div className="main-content-grid-enhanced">
        {/* Upcoming Classes Card */}
        <div className="dashboard-card upcoming-classes-card fade-in-up delay-4">
          <div className="card-header">
            <h2>
              <FaCalendarCheck className="card-icon" /> Upcoming Classes
            </h2>
          </div>
          {filteredTimetables?.length > 0 ? (
            <div className="upcoming-classes-list">
              {filteredTimetables.slice(0, 5).map((cls, index) => (
                <div key={cls.id || index} className="upcoming-class-item">
                  <div className="class-date-time">
                    <p className="day">{cls.Day}</p>
                    <p className="time">{cls.Time.split(" to ")[0]}</p>
                  </div>
                  <div className="class-details">
                    <p className="student-name">{cls.Student}</p>
                    <p className="subject-topic">
                      {cls.Subject} - {cls.Topic || "No Topic"}
                    </p>
                  </div>
                </div>
              ))}
            </div>
          ) : (
            <p className="no-data-message">No upcoming classes scheduled.</p>
          )}
        </div>

        {/* Demo Classes Card */}
        <div className="dashboard-card demo-classes-card fade-in-up delay-5">
          <div className="card-header">
            <h2>
              <FaBookOpen className="card-icon" /> Demo Class Insights
            </h2>
          </div>
          <div className="demo-visuals">
            <div className="demo-summary">
              <div className="metric-item">
                <FaCheckCircle className="status-icon success" />
                <p>Success</p>
                <span>{demoMetrics.successCount}</span>
              </div>
              <div className="metric-item">
                <FaClock className="status-icon scheduled" />
                <p>Scheduled</p>
                <span>{demoMetrics.scheduledCount}</span>
              </div>
              <div className="metric-item">
                <FaHourglassHalf className="status-icon pending" />
                <p>Pending</p>
                <span>{demoMetrics.pendingCount}</span>
              </div>
              <div className="metric-item">
                <FaTimesCircle className="status-icon failure" />
                <p>Failure</p>
                <span>{demoMetrics.failureCount}</span>
              </div>
            </div>
            <div className="recent-demo-list">
              <h3>Recent Demos</h3>
              {filteredDemoClasses?.length > 0 ? (
                filteredDemoClasses.slice(0, 5).map((demo, index) => (
                  <div key={demo.id || index} className="recent-demo-item">
                    <p className="demo-student-name">{demo.studentName}</p>
                    <span
                      className={`status-badge status-${demo.status?.toLowerCase()}`}
                    >
                      {demo.status}
                    </span>
                  </div>
                ))
              ) : (
                <p>No recent demos.</p>
              )}
            </div>
          </div>
        </div>

        {/* New: Student Progress Card */}
        <div className="dashboard-card student-progress-card fade-in-up delay-6">
          <div className="card-header">
            <h2>
              <FaUserGraduate className="card-icon" /> Student Progress
            </h2>
          </div>
          <div className="activity-list">
            {processedStudentActivity?.length > 0 ? (
              processedStudentActivity.slice(0, 5).map((student, index) => (
                <div key={student.id || index} className="activity-item">
                  <span className="activity-icon student-icon">
                    <FaUserGraduate />
                  </span>
                  <div className="activity-details">
                    <p className="activity-message">
                      <span className="activity-user">{student.Name}</span>
                      {"'s"} last class was **{student.Subject}**
                    </p>
                    <span className="activity-time">
                      {student.lastUpdatedClassesAt}
                    </span>
                  </div>
                </div>
              ))
            ) : (
              <p className="no-data-message">No recent student activity.</p>
            )}
          </div>
        </div>

        {/* New: Employee Activity Card */}
        <div className="dashboard-card employee-activity-card fade-in-up delay-7">
          <div className="card-header">
            <h2>
              <FaMoneyBillAlt className="card-icon" /> Employee Activity
            </h2>
          </div>
          <div className="activity-list">
            {processedEmployeeActivity?.length > 0 ? (
              processedEmployeeActivity.slice(0, 5).map((employee, index) => (
                <div key={employee.id || index} className="activity-item">
                  <span className="activity-icon employee-icon">
                    <FaUserTie />
                  </span>
                  <div className="activity-details">
                    <p className="activity-message">
                      <span className="activity-user">{employee.name}</span>'s
                      salary is
                      <strong
                        className={`payment-status status-${
                          employee.paid ? "paid" : "unpaid"
                        }`}
                      >
                        {employee.paid ? " Paid" : " Unpaid"}
                      </strong>
                    </p>
                    <span className="activity-time">
                      Last paid: {employee.lastPaid || "N/A"}
                    </span>
                  </div>
                </div>
              ))
            ) : (
              <p className="no-data-message">No recent employee activity.</p>
            )}
          </div>
        </div>
      </div>
    </div>
  );
};

export default Dashboard;
