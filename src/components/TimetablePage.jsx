import React, { useState, useEffect, useMemo, useCallback } from "react";
import { useNavigate, useLocation } from "react-router-dom";
import { topicOptions } from "../mockdata/Options";
import {
  FaCalendarAlt,
  FaChalkboardTeacher,
  FaUserGraduate,
  FaBook,
  FaClock,
  FaFilter,
  FaPlusCircle,
  FaSearch,
  FaInfoCircle,
  FaHourglassHalf,
  FaExclamationCircle,
  FaRobot,
  FaSave,
} from "react-icons/fa";
import { MdCurrencyRupee, MdEdit, MdDelete } from "react-icons/md";
import useDidMountEffect from "../components/customcomponents/useDidMountEffect";

import {
  format,
  parse,
  isValid,
  startOfDay,
  endOfDay,
  addDays,
  startOfWeek,
  endOfWeek,
  startOfMonth,
  endOfMonth,
  startOfYear,
  endOfYear,
  isWithinInterval,
  differenceInMinutes,
  addWeeks,
  getDay,
  isSameDay,
  addHours,
  isAfter, // New: More explicit time comparison
  addMinutes,
  constructNow, // To calculate end time for "running" check
} from "date-fns";
import { getTimetableRowStatus } from "../mockdata/funcation";
import {
  Typography,
  Box,
  Paper,
  TableContainer,
  Table,
  TableHead,
  TableBody,
  TableRow,
  TableCell,
  CircularProgress,
  Alert,
  Slide,
  Fade,
  Dialog,
  DialogActions,
  DialogContent,
  DialogContentText,
  DialogTitle,
  Snackbar,
  TextField,
  MenuItem,
  IconButton,
  Tooltip,
  Button,
  TableFooter,
} from "@mui/material";
import EditIcon from "@mui/icons-material/Edit";
import DeleteIcon from "@mui/icons-material/Delete";
import AddIcon from "@mui/icons-material/Add";
import AutoFixHighIcon from "@mui/icons-material/AutoFixHigh";
import MuiAlert from "@mui/material/Alert";

import {
  MuiInput,
  MuiSelect,
  MuiButton,
  MuiDatePicker,
} from "../components/customcomponents/MuiCustomFormFields";

import "./TimetablePage.css";
import {
  fetchUpcomingClasses,
  fetchStudents,
  deleteTimetable,
  fetchAutoTimetablesForToday,
  saveAutoGeneratedTimetables,
  updateAutoTimetableEntry,
  deleteAutoTimetable,
} from "../redux/actions";
import { useSelector, useDispatch } from "react-redux";
import PdfDownloadButton from "./customcomponents/PdfDownloadButton";
import { getDateFromTimetableItem } from "../mockdata/funcation";
const TimetablePage = () => {
  const navigate = useNavigate();
  const dispatch = useDispatch();
  const {
    timetables: manualTimetables, // Renamed from 'timetables' for clarity with autoTimetables
    loading: classesLoading,
    error: classesError,
  } = useSelector((state) => state.classes);
  const {
    students,
    loading: studentsLoading,
    error: studentsError,
  } = useSelector((state) => state.students);
  const {
    timetables: autoTimetables, // NEW: This will hold auto-generated timetables
    loading: autoTimetablesLoading,
    error: autoTimetablesError,
    hasSavedToday: autoTimetablesHasSavedToday, // NEW: Track if auto-timetables were saved for today
  } = useSelector((state) => state.autoTimetables); // This is your NEW autoTimetables reducer
  const { user } = useSelector((state) => state.auth);

  const [searchTerm, setSearchTerm] = useState("");
  const [filterDurationType, setFilterDurationType] = useState("Daily");
  const [filterDate, setFilterDate] = useState(new Date());

  const [openDeleteConfirm, setOpenDeleteConfirm] = useState(false);
  const [timetableToDelete, setTimetableToDelete] = useState(null);

  const [autoGeneratedTimetables, setAutoGeneratedTimetables] = useState([]);
  const [isGeneratingAuto, setIsGeneratingAuto] = useState(false);
  const [autoGenerateErrorMsg, setAutoGenerateErrorMsg] = useState(null);
  const [hasGeneratedOnce, setHasGeneratedOnce] = useState(false); // New state to track initial generation

  const [snackbarOpen, setSnackbarOpen] = useState(false);
  const [snackbarMessage, setSnackbarMessage] = useState("");
  const [snackbarSeverity, setSnackbarSeverity] = useState("success");
  const [isDeleting, setIsDeleting] = useState(false); // For delete loading state
  // --- NEW STATE TO CONTROL AUTO-GENERATION ---
  // This state tracks if an attempt to auto-generate for today has already been made
  // during the current component's lifecycle.
  const [hasAttemptedAutoGenerateSession, setHasAttemptedAutoGenerateSession] =
    useState(false);
  const { currentUserFaculty, currentUserSubject, canAccessAll } =
    useMemo(() => {
      let faculty = "";
      let subject = "";
      let allAccess = false;
      if (user) {
        if (user.isPhysics) {
          faculty = "Dulam";
          subject = "Physics";
        } else if (user.isChemistry) {
          faculty = "Bollam";
          subject = "Chemistry";
        } else if (user.AllowAll) {
          allAccess = true;
        }
      }
      return {
        currentUserFaculty: faculty,
        currentUserSubject: subject,
        canAccessAll: allAccess,
      };
    }, [user]);

  // Improved helper function to convert single time string to slot format
  const convertSingleTimeToSlot = useCallback((singleTime) => {
    if (!singleTime || typeof singleTime !== "string") {
      return null;
    }
    singleTime = singleTime.trim();

    // If it's already in the "HH:MM AM/PM to HH:MM AM/PM" format, return as is
    if (singleTime.includes(" to ")) {
      const [start, end] = singleTime.split(" to ");
      if (
        isValid(parse(start.trim(), "hh:mm a", new Date())) &&
        isValid(parse(end.trim(), "hh:mm a", new Date()))
      ) {
        return singleTime;
      }
    }

    try {
      let parsedTime = parse(singleTime, "hh:mm a", new Date());
      if (!isValid(parsedTime)) {
        parsedTime = parse(singleTime, "h:mm a", new Date());
      }
      if (!isValid(parsedTime)) {
        parsedTime = parse(singleTime, "hh:mma", new Date());
      }
      if (!isValid(parsedTime)) {
        parsedTime = parse(singleTime, "h:mma", new Date());
      }
      if (!isValid(parsedTime)) {
        // Fallback for cases like "6am" or "7pm" - assumes no minutes
        const match = singleTime.match(/(\d+)(am|pm)/i);
        if (match) {
          const hour = parseInt(match[1], 10);
          const ampm = match[2].toLowerCase();
          let tempDate = new Date();
          tempDate.setHours(
            hour +
              (ampm === "pm" && hour !== 12
                ? 12
                : ampm === "am" && hour === 12
                ? -12
                : 0),
            0,
            0,
            0
          );
          parsedTime = tempDate;
        }
      }

      if (isValid(parsedTime)) {
        const endTime = addHours(parsedTime, 1); // Assuming 1-hour class
        return `${format(parsedTime, "hh:mm a")} to ${format(
          endTime,
          "hh:mm a"
        )}`;
      } else {
        return null;
      }
    } catch (e) {
      return null;
    }
  }, []);

  const availableTopicOptions = useMemo(() => topicOptions, []);

  // Helper map for day names to day numbers (Sunday 0, Monday 1, ..., Saturday 6)
  const dayNameToDayNum = useMemo(
    () => ({
      Sunday: 0,
      Monday: 1,
      Tuesday: 2,
      Wednesday: 3,
      Thursday: 4,
      Friday: 5,
      Saturday: 6,
    }),
    []
  );

  const generateTimetablesForStudents = useCallback(async () => {
    if (isGeneratingAuto) {
      console.log("Already generating, skipping new call.");
      return;
    }

    if (
      studentsLoading ||
      classesLoading ||
      autoTimetablesLoading ||
      !user ||
      !user.id || // CRITICAL: Ensure user.id is present before attempting generation
      !students ||
      students.length === 0
    ) {
      console.warn("Generation skipped: Data not ready or no user/students.");
      if (!user || !user.id)
        setSnackbarMessage(
          "User data not loaded or not authorized. Cannot auto-generate."
        );
      else if (students.length === 0)
        setSnackbarMessage("No students found to generate timetables for.");
      setSnackbarSeverity("warning");
      setSnackbarOpen(true);
      return;
    }

    // CRITICAL: Check if auto-timetables already exist for TODAY for this user
    // This check now relies on the `autoTimetablesHasSavedToday` from Redux,
    // which reflects the backend's `autoTimetables/today` API call.
    if (autoTimetablesHasSavedToday) {
      console.log(
        `Auto-generated timetables for today already exist in DB for this user. Skipping regeneration.`
      );
      setAutoGenerateErrorMsg(null);
      setIsGeneratingAuto(false);
      setSnackbarSeverity("info");
      setSnackbarMessage(
        "Daily auto-timetables already generated and saved for today."
      );
      setSnackbarOpen(true);
      return; // DO NOT regenerate if already saved for today based on backend check
    }

    setIsGeneratingAuto(true);
    setAutoGenerateErrorMsg(null);
    const generated = [];
    const now = new Date();
    const startOfToday = startOfDay(now);
    const endOfToday = endOfDay(now);
    const todayDayNum = getDay(now);
    const todayFormatted = format(startOfToday, "yyyy-MM-dd");

    const relevantStudents = students
      .filter(
        (student) =>
          canAccessAll || student.Subject?.trim() === currentUserSubject
      )
      .sort((a, b) => a.Name.localeCompare(b.Name));

    if (relevantStudents.length === 0) {
      setAutoGenerateErrorMsg(
        "No relevant students found for timetable generation based on your permissions."
      );
      setIsGeneratingAuto(false);
      setSnackbarSeverity("warning");
      setSnackbarMessage("No relevant students found to auto-generate for.");
      setSnackbarOpen(true);
      setHasAttemptedAutoGenerateSession(true); // Attempted, nothing generated, mark as done for today
      return;
    }

    // Combine existing manual and already saved auto timetables for clash detection
    // Note: 'autoTimetables' now comes from the Redux store (fetched from the DB)
    const allExistingTimetables = [...manualTimetables, ...autoTimetables];
    const occupiedSlots = new Set(); // Stores "YYYY-MM-DD_HH:MM AM/PM_EntityName"

    allExistingTimetables.forEach((tt) => {
      try {
        const timeStartPart = tt.Time.split(" to ")[0];
        const dateObj = parse(tt.Day, "dd/MM/yyyy", new Date());
        const combinedDateTime = parse(
          `${format(dateObj, "yyyy-MM-dd")} ${timeStartPart}`,
          "yyyy-MM-dd hh:mm a",
          new Date()
        );

        if (isValid(combinedDateTime)) {
          const formattedDateTime = format(
            combinedDateTime,
            "yyyy-MM-dd_hh:mm a"
          );
          occupiedSlots.add(`${formattedDateTime}_${tt.Student}`);
          occupiedSlots.add(`${formattedDateTime}_${tt.Faculty}`);
        } else {
          console.warn(
            `Could not parse existing timetable date/time for clash detection: ${tt.Day} ${tt.Time}`
          );
        }
      } catch (e) {
        console.error(
          "Error processing existing timetable for occupiedSlots:",
          tt,
          e
        );
      }
    });
    console.log(
      "Occupied slots from existing timetables (manual + auto saved):",
      occupiedSlots.size
    );

    relevantStudents.forEach((student) => {
      console.log(`\n--- Processing student: ${student.Name} ---`);
      const studentName = student.Name;
      const studentSubject = student.Subject || currentUserSubject;
      const studentFaculty =
        student.Faculty ||
        (studentSubject === "Physics"
          ? "Dulam"
          : studentSubject === "Chemistry"
          ? "Bollam"
          : currentUserFaculty);
      const studentYear = student.Year?.trim();

      let selectedTopic = student.TopicTemplate;

      if (
        !selectedTopic &&
        availableTopicOptions &&
        availableTopicOptions.length > 0
      ) {
        const filteredTopics = availableTopicOptions
          .filter(
            (topic) =>
              topic.subject === studentSubject && topic.year === studentYear
          )
          .sort((a, b) => a.id - b.id);

        if (filteredTopics.length > 0) {
          const progressTopicId = student.syllabusProgress
            ? parseInt(student.syllabusProgress, 10)
            : 0;
          let nextTopic = filteredTopics.find((t) => t.id > progressTopicId);

          if (nextTopic) {
            selectedTopic = nextTopic.topic;
          } else {
            selectedTopic = filteredTopics[0].topic;
          }
        }
      }

      if (!selectedTopic) {
        selectedTopic = `${studentSubject} Class`;
      }

      const preferredSlotsWithDays = (student.classDateandTime || [])
        .map((item) => {
          const parts = item.split("-");
          if (parts.length === 2) {
            const dayOfWeekName = parts[0].trim();
            const timeStr = parts[1].trim();
            const formattedTimeSlot = convertSingleTimeToSlot(timeStr);
            const dayNum = dayNameToDayNum[dayOfWeekName];
            if (formattedTimeSlot && dayNum !== undefined) {
              return {
                dayOfWeekName,
                dayNum,
                formattedTimeSlot,
              };
            }
          }
          return null;
        })
        .filter(Boolean);

      const classesNeeded = parseInt(student.classesPerWeek || 1, 10);
      if (classesNeeded <= 0 || preferredSlotsWithDays.length === 0) {
        console.log(
          `Student ${studentName}: Skipping, no classes needed or no valid preferred slots.`
        );
        return;
      }

      let classesAssigned = 0;
      const candidateSlotsForStudent = [];

      const preferredSlotsForToday = preferredSlotsWithDays.filter(
        (slot) => slot.dayNum === todayDayNum
      );

      for (const preferredSlot of preferredSlotsForToday) {
        const selectedTimeSlot = preferredSlot.formattedTimeSlot;
        const timePartStart = selectedTimeSlot.split(" to ")[0];
        const classStartTimeObj = parse(timePartStart, "hh:mm a", startOfToday);

        const isValidTime = isValid(classStartTimeObj);
        const isWithinToday =
          isValidTime &&
          isWithinInterval(classStartTimeObj, {
            start: startOfToday,
            end: endOfToday,
          });

        if (isValidTime && isWithinToday) {
          candidateSlotsForStudent.push({
            classStartTimeObj: classStartTimeObj,
            formattedTimeSlot: selectedTimeSlot,
            formattedDay: format(classStartTimeObj, "dd/MM/yyyy"),
            isFuture: isAfter(classStartTimeObj, now),
          });
        }
      }

      candidateSlotsForStudent.sort((a, b) => {
        if (a.isFuture && !b.isFuture) return -1;
        if (!a.isFuture && b.isFuture) return 1;
        return a.classStartTimeObj.getTime() - b.classStartTimeObj.getTime();
      });

      for (let i = 0; i < candidateSlotsForStudent.length; i++) {
        const candidate = candidateSlotsForStudent[i];
        if (classesAssigned >= classesNeeded) {
          break;
        }

        const studentSlotKey = `${format(
          candidate.classStartTimeObj,
          "yyyy-MM-dd_hh:mm a"
        )}_${studentName}`;
        const facultySlotKey = `${format(
          candidate.classStartTimeObj,
          "yyyy-MM-dd_hh:mm a"
        )}_${studentFaculty}`;

        if (
          !occupiedSlots.has(studentSlotKey) &&
          !occupiedSlots.has(facultySlotKey)
        ) {
          generated.push({
            Student: studentName,
            Topic: "",
            Day: candidate.formattedDay,
            Faculty: studentFaculty,
            Subject: studentSubject,
            Time: candidate.formattedTimeSlot,
          });

          occupiedSlots.add(studentSlotKey);
          occupiedSlots.add(facultySlotKey);
          classesAssigned++;
        }
      }
    });

    if (generated.length > 0) {
      const finalGeneratedItems = generated.map((item) => ({
        ...item,
        userId: user.id, // Add userId here
        generationDate: todayFormatted, // Add generationDate here
      }));
      console.log("sdfsdf", autoTimetables);
      try {
        await dispatch(saveAutoGeneratedTimetables(finalGeneratedItems));
        setSnackbarSeverity("success");
        setSnackbarMessage(
          `Successfully generated and saved ${finalGeneratedItems.length} timetables for today!`
        );
        setSnackbarOpen(true);
        // setHasAttemptedAutoGenerateSession(true); // Mark as attempted for this session
      } catch (error) {
        setAutoGenerateErrorMsg(
          `Failed to save auto-generated timetables: ${error.message}`
        );
        setSnackbarSeverity("error");
        setSnackbarMessage(
          `Failed to save auto-generated timetables: ${error.message}`
        );
        setSnackbarOpen(true);
      }
    } else {
      setSnackbarSeverity("info");
      setSnackbarMessage(
        "No new timetables could be auto-generated for today."
      );
      setSnackbarOpen(true);
    }
    // --- CRITICAL: Set this after all generation/saving attempts (success or failure) ---
    setHasAttemptedAutoGenerateSession(true); // <-- Moved to end
    setIsGeneratingAuto(false); // Ensure this is always reset
  }, [
    students,
    user,
    currentUserSubject,
    currentUserFaculty,
    canAccessAll,
    studentsLoading,
    classesLoading,
    autoTimetablesLoading,
    autoTimetablesHasSavedToday, // Use the Redux state to check if already saved
    manualTimetables,
    autoTimetables, // Ensure this is a dependency
    dispatch,
    convertSingleTimeToSlot,
    isGeneratingAuto,
  ]);
  // TimetablePage.jsx

  // This handles initial GET requests, preventing them from doubling in StrictMode.
  useDidMountEffect(() => {
    console.log(
      "Effect 1: Running initial data fetches (single call in StrictMode dev)."
    );
    dispatch(fetchUpcomingClasses());
    dispatch(fetchStudents());
    if (user && user.id) {
      console.log(
        "Effect 1: Dispatching fetchAutoTimetablesForToday for user:",
        user.id
      );
      dispatch(fetchAutoTimetablesForToday());
    } else {
      console.warn(
        "Effect 1: User or user.id is not available yet for fetching auto timetables. Will retry if user becomes available."
      );
    }
  }, [dispatch, user]);

  // --- EFFECT 2: Trigger Generation Logic (Apply useDidMountEffect here for write operation) ---
  // This ensures `generateTimetablesForStudents()` is only called ONCE on initial mount
  // even in StrictMode's double-render phase.
  useDidMountEffect(() => {
    // <--- CHANGED from useEffect to useDidMountEffect
    console.log(
      "Effect 2: Checking conditions for auto-generation (single call in StrictMode dev). State:",
      {
        user: user ? user.id : "N/A",
        studentsLoading,
        classesLoading,
        studentsCount: students?.length,
        autoTimetablesLoading,
        autoTimetablesHasSavedToday,
        hasAttemptedAutoGenerateSession,
      }
    );

    // 1. Pre-checks (user logged in, basic data loaded)
    if (
      !user ||
      !user.id ||
      studentsLoading ||
      classesLoading ||
      !students ||
      students.length === 0
    ) {
      console.log(
        "Effect 2: Data not ready or user not logged in. Skipping generation trigger."
      );
      return;
    }

    // 2. CRITICAL: Wait for the initial fetch for autoTimetables to complete
    if (autoTimetablesLoading) {
      console.log(
        "Effect 2: Auto timetables are still loading. Waiting for fetch to complete."
      );
      return;
    }

    // 3. CRITICAL: If the fetch completed and found existing timetables, DO NOT GENERATE/SAVE
    // If it successfully loaded existing timetables, mark as attempted to prevent future re-generation
    if (autoTimetablesHasSavedToday) {
      console.log(
        "Effect 2: Auto timetables already exist for today. No generation needed."
      );
      setHasAttemptedAutoGenerateSession(true); // Ensure flag is set if existing data found
      return;
    }

    // 4. NEW CRITICAL CHECK: Prevent re-running if an attempt has already been made in this session
    // This is crucial for preventing redundant generations if dependencies change after the first attempt.
    if (hasAttemptedAutoGenerateSession) {
      console.log(
        "Effect 2: Already attempted auto-generation in this session. Skipping re-trigger."
      );
      return;
    }

    console.log(
      "Effect 2: Conditions met for auto-generation. Calling generateTimetablesForStudents()."
    );
    // IMPORTANT: Set the flag *before* calling the async function that dispatches the save.
    // This ensures the flag is set immediately for the next render cycle.
    setHasAttemptedAutoGenerateSession(true);
    generateTimetablesForStudents();
  }, [
    dispatch,
    user,
    students,
    studentsLoading,
    classesLoading,
    autoTimetablesLoading,
    autoTimetablesHasSavedToday,
    generateTimetablesForStudents,
    hasAttemptedAutoGenerateSession, // Keep this dependency to allow the effect to react if it changes later
  ]);

  const durationOptions = useMemo(() => {
    const today = new Date();
    const formatDateForLabel = (date) => format(date, "dd/MM/yyyy");

    return [
      { value: "Daily", label: `Daily (${formatDateForLabel(filterDate)})` },
      {
        value: "2days",
        label: `Next 2 Days (until ${formatDateForLabel(addDays(today, 1))})`,
      },
      {
        value: "3days",
        label: `Next 3 Days (until ${formatDateForLabel(addDays(today, 2))})`,
      },
      {
        value: "4days",
        label: `Next 4 Days (until ${formatDateForLabel(addDays(today, 3))})`,
      },
      {
        value: "5days",
        label: `Next 5 Days (until ${formatDateForLabel(addDays(today, 4))})`,
      },
      {
        value: "Week",
        label: `This Week (until ${formatDateForLabel(
          endOfWeek(today, { weekStartsOn: 1 })
        )})`,
      },
      {
        value: "Month",
        label: `This Month (until ${formatDateForLabel(endOfMonth(today))})`,
      },
      {
        value: "Year",
        label: `This Year (until ${formatDateForLabel(endOfYear(today))})`,
      },
    ];
  }, [filterDate]);

  const calculateDuration = useCallback((timeString) => {
    try {
      const [startTimeStr, endTimeStr] = timeString.split(" to ");
      if (!startTimeStr || !endTimeStr) return "N/A";

      const now = new Date();
      const startTime = parse(startTimeStr.trim(), "hh:mm a", now);
      let endTime = parse(endTimeStr.trim(), "hh:mm a", now);

      if (!isValid(startTime) || !isValid(endTime)) {
        return "N/A";
      }

      if (endTime.getTime() < startTime.getTime()) {
        endTime = addDays(endTime, 1);
      }

      const minutes = differenceInMinutes(endTime, startTime);
      if (isNaN(minutes)) return "N/A";

      const hours = Math.floor(minutes / 60);
      const remainingMinutes = minutes % 60;

      if (hours === 0 && remainingMinutes === 0) {
        return "0 min";
      } else if (hours === 0) {
        return `${remainingMinutes} min`;
      } else if (remainingMinutes === 0) {
        return `${hours} hr`;
      } else {
        return `${hours} hr ${remainingMinutes} min`;
      }
    } catch (e) {
      return "N/A";
    }
  }, []);

  const combinedAndFilteredTimetables = useMemo(() => {
    // Combine manual and auto-generated timetables
    let combinedTimetables = [...manualTimetables, ...autoTimetables];

    let permissionFilteredTimetables = [];

    if (user && combinedTimetables && combinedTimetables.length > 0) {
      if (canAccessAll) {
        permissionFilteredTimetables = combinedTimetables;
      } else if (currentUserSubject) {
        permissionFilteredTimetables = combinedTimetables.filter(
          (schedule) => schedule.Subject?.trim() === currentUserSubject
        );
      } else {
        permissionFilteredTimetables = [];
      }
    } else if (!user) {
      permissionFilteredTimetables = [];
    }

    let currentTimetables = [...permissionFilteredTimetables];
    const now = new Date();

    let startDate = null;
    let endDate = null;

    switch (filterDurationType) {
      case "Daily":
        startDate = startOfDay(filterDate);
        endDate = endOfDay(filterDate);
        break;
      case "2days":
        startDate = startOfDay(now);
        endDate = endOfDay(addDays(now, 1));
        break;
      case "3days":
        startDate = startOfDay(now);
        endDate = endOfDay(addDays(now, 2));
        break;
      case "4days":
        startDate = startOfDay(now);
        endDate = endOfDay(addDays(now, 3));
        break;
      case "5days":
        startDate = startOfDay(now);
        endDate = endOfDay(addDays(now, 4));
        break;
      case "Week":
        startDate = startOfWeek(now, { weekStartsOn: 1 });
        endDate = endOfWeek(now, { weekStartsOn: 1 });
        break;
      case "Month":
        startDate = startOfMonth(now);
        endDate = endOfMonth(now);
        break;
      case "Year":
        startDate = startOfYear(now);
        endDate = endOfYear(now);
        break;
      default:
        break;
    }

    if (startDate && endDate) {
      currentTimetables = currentTimetables.filter((item) => {
        // Use classDateTime (Firestore Timestamp) or parse Day string
        let itemDate;
        if (item.classDateTime && item.classDateTime.toDate) {
          itemDate = item.classDateTime.toDate();
        } else {
          itemDate = parse(item.Day, "dd/MM/yyyy", new Date());
        }

        return (
          isValid(itemDate) &&
          isWithinInterval(itemDate, { start: startDate, end: endDate })
        );
      });
    }

    if (searchTerm) {
      currentTimetables = currentTimetables.filter(
        (item) =>
          item.Faculty?.toLowerCase().includes(searchTerm.toLowerCase()) ||
          item.Subject?.toLowerCase().includes(searchTerm.toLowerCase()) ||
          item.Topic?.toLowerCase().includes(searchTerm.toLowerCase()) ||
          item.Student?.toLowerCase().includes(searchTerm.toLowerCase()) ||
          item.Time?.toLowerCase().includes(searchTerm.toLowerCase())
      );
    }

    const studentSubjectFeeMap = new Map();
    if (students && students.length > 0) {
      students.forEach((student) => {
        if (student.Name && student.Subject) {
          const key = `${student.Name.toLowerCase()}_${student.Subject.toLowerCase()}`;
          studentSubjectFeeMap.set(key, student);
        }
      });
    }

    currentTimetables = currentTimetables.map((item) => {
      const studentNameLower = item.Student?.toLowerCase();
      const subjectLower = item.Subject?.toLowerCase();
      const lookupKey = `${studentNameLower}_${subjectLower}`;

      const matchedStudent = studentSubjectFeeMap.get(lookupKey);
      let monthlyFeePerClass = "N/A";
      if (matchedStudent) {
        let feeToUse = 0;
        if (
          typeof matchedStudent.monthlyFee === "number" &&
          matchedStudent.monthlyFee > 0
        ) {
          feeToUse = matchedStudent.monthlyFee;
        } else if (
          typeof matchedStudent["Monthly Fee"] === "string" &&
          parseFloat(matchedStudent["Monthly Fee"]) > 0
        ) {
          feeToUse = parseFloat(matchedStudent["Monthly Fee"]);
        }

        if (feeToUse > 0) {
          monthlyFeePerClass = (feeToUse / 12).toFixed(2);
        }
      }

      return {
        ...item,
        monthlyFeePerClass: monthlyFeePerClass,
      };
    });

    currentTimetables.sort((a, b) => {
      const dateA = getDateFromTimetableItem(a);
      const dateB = getDateFromTimetableItem(b);

      if (dateA.getTime() !== dateB.getTime()) {
        return dateA.getTime() - dateB.getTime();
      }

      const timeA = parse(a.Time?.split(" to ")[0], "hh:mm a", new Date());
      const timeB = parse(b.Time?.split(" to ")[0], "hh:mm a", new Date());
      return timeA.getTime() - timeB.getTime();
    });

    return currentTimetables;
  }, [
    manualTimetables,
    autoTimetables, // Make sure autoTimetables is a dependency
    searchTerm,
    filterDurationType,
    filterDate,
    user,
    students,
    currentUserSubject,
    canAccessAll,
    calculateDuration,
  ]);

  const handleSearchChange = (e) => {
    setSearchTerm(e.target.value);
  };

  const handleFilterDurationChange = (e) => {
    setFilterDurationType(e.target.value);
    setFilterDate(new Date());
  };

  const handleAddTimetableClick = () => {
    // This will still add to the manual timetables
    navigate("/add-timetable");
  };

  const handleEditTimetable = (timetableItem) => {
    // Determine if it's an auto-generated timetable based on 'isAutoGenerated' flag
    // or by checking if its ID exists in the 'autoTimetables' Redux state.
    // The 'isAutoGenerated' flag added in the backend save is more reliable.
    const isFromAutoTimetables = timetableItem.isAutoGenerated === true;

    navigate("/add-timetable", {
      state: {
        timetableToEdit: {
          ...timetableItem,
          isAutoGeneratedInDb: isFromAutoTimetables, // Pass this flag to the Add/Edit page
        },
      },
    });
  };

  const handleDeleteClick = (item) => {
    const isFromAutoTimetables = item.isAutoGenerated === true;
    setTimetableToDelete({
      ...item,
      isAutoGeneratedInDb: isFromAutoTimetables,
    });
    setOpenDeleteConfirm(true);
  };

  const handleCloseDeleteConfirm = () => {
    setOpenDeleteConfirm(false);
    setTimetableToDelete(null);
  };

  const handleDeleteConfirm = async () => {
    setIsDeleting(true);
    try {
      if (timetableToDelete.isAutoGeneratedInDb) {
        await dispatch(deleteAutoTimetable(timetableToDelete.id)); // Use new action
        setSnackbarSeverity("success");
        setSnackbarMessage("Auto-generated timetable deleted successfully!");
      } else {
        await dispatch(deleteTimetable(timetableToDelete.id)); // Use existing action
        setSnackbarSeverity("success");
        setSnackbarMessage("Manual timetable deleted successfully!");
      }
      setOpenDeleteConfirm(false);
      setTimetableToDelete(null);
      setSnackbarOpen(true);
    } catch (error) {
      setSnackbarSeverity("error");
      setSnackbarMessage(
        `Failed to delete timetable: ${error.message || "Unknown error"}`
      );
      setSnackbarOpen(true);
    } finally {
      setIsDeleting(false);
    }
  };

  const handleSnackbarClose = (event, reason) => {
    if (reason === "clickaway") {
      return;
    }
    setSnackbarOpen(false);
  };

  if (classesLoading || studentsLoading || isGeneratingAuto) {
    return (
      <Fade in={true} timeout={1000}>
        <Box
          sx={{
            display: "flex",
            flexDirection: "column",
            alignItems: "center",
            justifyContent: "center",
            minHeight: "80vh",
            gap: 2,
            backgroundColor: "#f7f8fc",
            p: 3,
          }}
        >
          <CircularProgress sx={{ color: "#1976d2" }} />
          <Typography variant="h6" color="text.secondary">
            {isGeneratingAuto
              ? "Generating and processing timetables..."
              : "Loading timetables and student data..."}
          </Typography>
        </Box>
      </Fade>
    );
  }

  if (classesError || studentsError) {
    return (
      <Fade in={true} timeout={1000}>
        <Box
          sx={{
            display: "flex",
            flexDirection: "column",
            alignItems: "center",
            justifyContent: "center",
            minHeight: "80vh",
            gap: 2,
            backgroundColor: "#f7f8fc",
            p: 3,
          }}
        >
          <Alert
            severity="error"
            sx={{ width: "100%", maxWidth: 400, justifyContent: "center" }}
          >
            <Typography
              variant="h6"
              sx={{ display: "flex", alignItems: "center" }}
            >
              <FaExclamationCircle style={{ marginRight: "10px" }} /> Error:{" "}
              {classesError || studentsError}
            </Typography>
          </Alert>
          <MuiButton
            variant="contained"
            onClick={() => window.location.reload()}
            sx={{
              bgcolor: "#1976d2",
              "&:hover": { bgcolor: "#1565c0" },
              borderRadius: "8px",
              px: 3,
              py: 1.2,
            }}
          >
            Retry
          </MuiButton>
        </Box>
      </Fade>
    );
  }

  const showSubjectColumn = user?.AllowAll;
  const getPdfTableHeaders = () => {
    const pdfHeaders = ["Student", "Lesson", "Date"];
    if (showSubjectColumn) {
      pdfHeaders.push("Faculty");
      pdfHeaders.push("Subject");
    }
    pdfHeaders.push("Time");
    pdfHeaders.push("Duration");
    pdfHeaders.push("Fee / Class");
    return pdfHeaders;
  };

  const getPdfTableRows = () => {
    // Only include non-auto-generated timetables for PDF, as proposed ones aren't saved yet
    return combinedAndFilteredTimetables
      .filter((item) => !item.isAutoGenerated)
      .map((item) => {
        const row = [item.Student, item.Topic, item.Day];
        if (showSubjectColumn) {
          row.push(item.Faculty);
          row.push(item.Subject);
        }
        row.push(item.Time);
        row.push(calculateDuration(item.Time));
        row.push(
          item.monthlyFeePerClass !== "N/A"
            ? String(item.monthlyFeePerClass)
            : "N/A"
        );
        return row;
      });
  };
  const getPdfTitle = () => {
    const pdfTimetables = combinedAndFilteredTimetables.filter(
      (item) => !item.isAutoGenerated
    );
    if (pdfTimetables.length === 0) {
      return "Timetable Report";
    }

    const uniqueSubjects = [
      ...new Set(pdfTimetables.map((item) => item.Subject)),
    ];

    if (uniqueSubjects.length === 1) {
      const subject = uniqueSubjects[0];
      if (subject === "Physics") {
        return "Dulam Timetable";
      } else if (subject === "Chemistry") {
        return "Bollam Timetable";
      }
    }
    return "General Timetable Report";
  };
  const isLoading =
    classesLoading ||
    studentsLoading ||
    autoTimetablesLoading ||
    isGeneratingAuto ||
    isDeleting;
  const { sumHours, sumFee } = combinedAndFilteredTimetables.reduce(
    (acc, item) => {
      // Calculate duration safely
      const duration = parseFloat(calculateDuration(item.Time));
      if (!isNaN(duration)) {
        acc.sumHours += duration;
      }

      // Extract fee, remove '₹', and convert to number
      if (item.monthlyFeePerClass && item.monthlyFeePerClass !== "N/A") {
        const feeValue = parseFloat(item.monthlyFeePerClass.replace("₹", ""));
        if (!isNaN(feeValue)) {
          acc.sumFee += feeValue;
        }
      }
      return acc;
    },
    { sumHours: 0, sumFee: 0 } // Initial accumulator values
  );
  return (
    <Box
      sx={{
        minHeight: "100vh",
        backgroundColor: "#f7f8fc",
        p: 3,
        display: "flex",
        flexDirection: "column",
        gap: 3,
      }}
    >
      {isLoading && (
        <Box sx={{ display: "flex", justifyContent: "center", my: 2 }}>
          <CircularProgress />
          <Typography sx={{ ml: 2 }}>Loading timetables...</Typography>
        </Box>
      )}
      {/* Header Card */}
      <Slide
        direction="down"
        in={true}
        mountOnEnter
        unmountOnExit
        timeout={500}
      >
        <Paper
          elevation={6}
          sx={{
            p: 3,
            display: "flex",
            alignItems: "center",
            justifyContent: "space-between",
            borderBottom: "1px solid rgba(0, 0, 0, 0.08)",
            flexWrap: "wrap",
            gap: 2,
            borderRadius: "12px",
          }}
        >
          <Box sx={{ display: "flex", alignItems: "center" }}>
            <FaCalendarAlt
              style={{
                marginRight: "15px",
                fontSize: "2.5rem",
                color: "#1976d2",
              }}
            />
            <Box>
              <Typography
                variant="h4"
                component="h1"
                sx={{ color: "#292551", fontWeight: 700, mb: 0.5 }}
              >
                Timetable
              </Typography>
              <Typography variant="body1" color="text.secondary">
                View and manage your scheduled classes. Today is{" "}
                <span className="current-date">
                  {format(new Date(), "EEEE, MMMM dd,yyyy")}
                </span>
                .
              </Typography>
            </Box>
          </Box>
          {combinedAndFilteredTimetables.length > 0 && (
            <PdfDownloadButton
              title={getPdfTitle()} // Dynamic title
              headers={getPdfTableHeaders()}
              rows={getPdfTableRows()}
              buttonLabel="Download Timetable (PDF)"
              filename="Timetable_Report.pdf"
              reportDate={new Date()}
            />
          )}
          <MuiButton
            variant="contained"
            startIcon={<FaPlusCircle />}
            onClick={handleAddTimetableClick}
            sx={{
              bgcolor: "#1976d2", // Changed to primary blue
              "&:hover": { bgcolor: "#1565c0" }, // Darker blue on hover
              borderRadius: "8px",
              px: 3,
              py: 1.2,
              minWidth: "180px",
              boxShadow: "0px 4px 10px rgba(0, 0, 0, 0.1)", // Subtle shadow
            }}
          >
            Add Timetable
          </MuiButton>
        </Paper>
      </Slide>

      {/* Filters and Search Section with Slide animation */}
      <Slide
        direction="right"
        in={true}
        mountOnEnter
        unmountOnExit
        timeout={600}
      >
        <Paper elevation={6} sx={{ p: 3, borderRadius: "12px" }}>
          {" "}
          {/* Increased elevation, rounded corners */}
          <Box
            sx={{
              display: "flex",
              alignItems: "center",
              justifyContent: "space-between",
              mb: 3,
              flexWrap: "wrap",
              gap: 2,
            }}
          >
            <Typography
              variant="h5"
              component="h2"
              sx={{
                display: "flex",
                alignItems: "center",
                color: "#292551", // Darker text for headings
                fontWeight: 600,
              }}
            >
              <FaFilter
                style={{
                  marginRight: "10px",
                  fontSize: "1.8rem",
                  color: "#1976d2",
                }}
              />{" "}
              Filters
            </Typography>
          </Box>
          <Box sx={{ display: "flex", gap: 2, flexWrap: "wrap" }}>
            {/* Search Input */}
            <Box
              sx={{
                flexGrow: 1,
                minWidth: { xs: "100%", sm: "200px" },
                maxWidth: { xs: "100%", sm: "350px" },
              }}
            >
              <MuiInput
                label="Search"
                icon={FaSearch}
                name="searchTerm"
                value={searchTerm}
                onChange={handleSearchChange}
                placeholder="Search by faculty, subject, topic, student..."
              />
            </Box>

            {/* New: Duration Filter Dropdown */}
            <Box sx={{ minWidth: { xs: "100%", sm: "150px" } }}>
              <MuiSelect
                label="Show"
                name="filterDurationType"
                value={filterDurationType}
                onChange={handleFilterDurationChange}
                options={durationOptions}
                icon={FaCalendarAlt}
              />
            </Box>

            {/* Only show DatePicker if 'Daily' filter is selected */}
            {filterDurationType === "Daily" && (
              <Box sx={{ minWidth: { xs: "100%", sm: "150px" } }}>
                <MuiDatePicker
                  label="Specific Date"
                  icon={FaCalendarAlt}
                  name="filterDate"
                  value={format(filterDate, "yyyy-MM-dd")}
                  onChange={(e) => setFilterDate(parseISO(e.target.value))}
                />
              </Box>
            )}
          </Box>
        </Paper>
      </Slide>

      {/* Timetable Table with Slide animation */}
      <Slide direction="up" in={true} mountOnEnter unmountOnExit timeout={700}>
        <Paper
          elevation={6}
          sx={{ p: 2, overflowX: "auto", borderRadius: "12px" }}
        >
          {combinedAndFilteredTimetables.length > 0 ? (
            <TableContainer>
              <Table sx={{ minWidth: 800 }} aria-label="timetable">
                <TableHead>
                  <TableRow sx={{ backgroundColor: "#e3f2fd" }}>
                    <TableCell
                      sx={{
                        color: "#1a237e",
                        fontWeight: "bold",
                        fontSize: "1.05rem",
                        padding: "18px 12px",
                        textAlign: "center",
                      }}
                    >
                      <Box
                        sx={{
                          display: "flex",
                          alignItems: "center",
                          justifyContent: "center",
                        }}
                      >
                        <FaBook
                          style={{ marginRight: "8px", color: "#1976d2" }}
                        />{" "}
                        Sl. No
                      </Box>
                    </TableCell>
                    <TableCell
                      sx={{
                        color: "#1a237e",
                        fontWeight: "bold",
                        fontSize: "1.05rem",
                        padding: "18px 12px",
                        textAlign: "center",
                      }}
                    >
                      <Box
                        sx={{
                          display: "flex",
                          alignItems: "center",
                          justifyContent: "center",
                        }}
                      >
                        <FaUserGraduate
                          style={{ marginRight: "8px", color: "#1976d2" }}
                        />{" "}
                        Student
                      </Box>
                    </TableCell>
                    <TableCell
                      sx={{
                        color: "#1a237e",
                        fontWeight: "bold",
                        fontSize: "1.05rem",
                        padding: "18px 12px",
                        textAlign: "center",
                      }}
                    >
                      <Box
                        sx={{
                          display: "flex",
                          alignItems: "center",
                          justifyContent: "center",
                        }}
                      >
                        <FaInfoCircle
                          style={{ marginRight: "8px", color: "#1976d2" }}
                        />{" "}
                        Lesson
                      </Box>
                    </TableCell>
                    <TableCell
                      sx={{
                        color: "#1a237e",
                        fontWeight: "bold",
                        fontSize: "1.05rem",
                        padding: "18px 12px",
                        textAlign: "center",
                      }}
                    >
                      <Box
                        sx={{
                          display: "flex",
                          alignItems: "center",
                          justifyContent: "center",
                        }}
                      >
                        <FaCalendarAlt
                          style={{ marginRight: "8px", color: "#1976d2" }}
                        />{" "}
                        Date
                      </Box>
                    </TableCell>
                    {showSubjectColumn && (
                      <TableCell
                        sx={{
                          color: "#1a237e",
                          fontWeight: "bold",
                          fontSize: "1.05rem",
                          padding: "18px 12px",
                          textAlign: "center",
                        }}
                      >
                        <Box
                          sx={{
                            display: "flex",
                            alignItems: "center",
                            justifyContent: "center",
                          }}
                        >
                          <FaChalkboardTeacher
                            style={{ marginRight: "8px", color: "#1976d2" }}
                          />{" "}
                          Faculty
                        </Box>
                      </TableCell>
                    )}
                    {showSubjectColumn && (
                      <TableCell
                        sx={{
                          color: "#1a237e",
                          fontWeight: "bold",
                          fontSize: "1.05rem",
                          padding: "18px 12px",
                          textAlign: "center",
                        }}
                      >
                        <Box
                          sx={{
                            display: "flex",
                            alignItems: "center",
                            justifyContent: "center",
                          }}
                        >
                          <FaBook
                            style={{ marginRight: "8px", color: "#1976d2" }}
                          />{" "}
                          Subject
                        </Box>
                      </TableCell>
                    )}
                    <TableCell
                      sx={{
                        color: "#1a237e",
                        fontWeight: "bold",
                        fontSize: "1.05rem",
                        padding: "18px 12px",
                        textAlign: "center",
                      }}
                    >
                      <Box
                        sx={{
                          display: "flex",
                          alignItems: "center",
                          justifyContent: "center",
                        }}
                      >
                        <FaClock
                          style={{ marginRight: "8px", color: "#1976d2" }}
                        />{" "}
                        Time
                      </Box>
                    </TableCell>
                    <TableCell
                      sx={{
                        color: "#1a237e",
                        fontWeight: "bold",
                        fontSize: "1.05rem",
                        padding: "18px 12px",
                        textAlign: "center",
                      }}
                    >
                      <Box
                        sx={{
                          display: "flex",
                          alignItems: "center",
                          justifyContent: "center",
                        }}
                      >
                        <FaHourglassHalf
                          style={{ marginRight: "8px", color: "#1976d2" }}
                        />{" "}
                        Duration
                      </Box>
                    </TableCell>
                    <TableCell
                      sx={{
                        color: "#1a237e",
                        fontWeight: "bold",
                        fontSize: "1.05rem",
                        padding: "18px 12px",
                        textAlign: "center",
                      }}
                    >
                      <Box
                        sx={{
                          display: "flex",
                          alignItems: "center",
                          justifyContent: "center",
                        }}
                      >
                        <MdCurrencyRupee
                          style={{ marginRight: "8px", color: "#1976d2" }}
                        />{" "}
                        Fee / Class
                      </Box>
                    </TableCell>
                    <TableCell
                      sx={{
                        color: "#1a237e",
                        fontWeight: "bold",
                        fontSize: "1.05rem",
                        padding: "18px 12px",
                        textAlign: "center",
                      }}
                    >
                      Actions
                    </TableCell>
                  </TableRow>
                </TableHead>
                <TableBody>
                  {combinedAndFilteredTimetables.map((item, index) => {
                    const now = new Date();
                    const rowStatus = getTimetableRowStatus(item, now);

                    let rowSx = {};
                    let disableActions = false;
                    let tooltipEditTitle = "Edit";
                    let tooltipDeleteTitle = "Delete";

                    switch (rowStatus) {
                      case "pastToday":
                      case "pastDay":
                        rowSx = {
                          background:
                            "linear-gradient(90deg, #ffebee, #ffcdd2)",
                          borderLeft: "6px solid #d32f2f",
                          "& > td": {
                            color: "#b71c1c",
                            fontWeight: 600,
                          },
                        };
                        disableActions = false;
                        tooltipEditTitle = "Past class";
                        tooltipDeleteTitle = item.isAutoGenerated
                          ? "Cannot delete past or auto-generated classes"
                          : "Delete past class";
                        break;

                      case "running":
                        rowSx = {
                          animation: "runningPulseBackground 2s infinite",
                          borderLeft: "6px solid #1976d2",
                          backgroundColor: "#e3f2fd",
                          "& > td": {
                            color: "#0d47a1",
                            fontWeight: 600,
                          },
                        };
                        break;

                      case "futureToday":
                        rowSx = {
                          background:
                            "linear-gradient(90deg, #e8f5e9, #a5d6a7)",
                          borderLeft: "6px solid #388e3c",
                          "& > td": {
                            color: "#1b5e20",
                            fontWeight: 600,
                          },
                        };
                        break;

                      case "future":
                      default:
                        rowSx = {
                          background:
                            "linear-gradient(to right, #e3fcef, #c8e6c9)",
                          borderLeft: "4px solid #43a047",
                          "& > td": {
                            color: "#1b5e20",
                            fontWeight: 600,
                          },
                        };
                        break;
                    }

                    if (
                      item.isAutoGenerated &&
                      ["futureToday", "future", "running"].includes(rowStatus)
                    ) {
                      tooltipDeleteTitle =
                        "Cannot delete auto-generated classes";
                    } else if (
                      item.isAutoGenerated &&
                      ["pastToday", "pastDay"].includes(rowStatus)
                    ) {
                      tooltipDeleteTitle =
                        "Cannot delete past or auto-generated classes";
                    }

                    return (
                      <TableRow
                        key={item.id || index}
                        sx={{
                          ...rowSx,
                          borderRadius: "8px",
                          transition: "all 0.3s ease",
                          "&:hover": {
                            backgroundColor: rowStatus.startsWith("past")
                              ? "#f0f0f0"
                              : "#e0f7fa !important",
                            transform: rowStatus.startsWith("past")
                              ? "none"
                              : "scale(1.01)",
                            boxShadow: rowStatus.startsWith("past")
                              ? "none"
                              : "0 4px 16px rgba(0,0,0,0.08)",
                          },
                          "& > td": {
                            borderBottom:
                              "1px solid rgba(0, 0, 0, 0.05) !important",
                            fontSize: "0.95rem",
                            color: rowStatus.startsWith("past")
                              ? "#9e9e9e"
                              : "#424242",
                            textAlign: "center",
                            transition: "color 0.3s ease-in-out",
                          },
                        }}
                      >
                        <TableCell
                          sx={{
                            textDecoration: rowStatus.startsWith("past")
                              ? "line-through"
                              : "none",
                          }}
                        >
                          {index + 1}
                        </TableCell>
                        <TableCell
                          sx={{
                            textDecoration: rowStatus.startsWith("past")
                              ? "line-through"
                              : "none",
                          }}
                        >
                          {item.Student}
                        </TableCell>

                        <TableCell align="center">
                          <Box
                            sx={{
                              display: "flex",
                              alignItems: "center",
                              justifyContent: "center",
                              gap: 1,
                            }}
                          >
                            {rowStatus === "running" && (
                              <Box
                                component="span"
                                sx={{
                                  width: 10,
                                  height: 10,
                                  borderRadius: "50%",
                                  backgroundColor: "#4caf50",
                                  animation:
                                    "dotPulse 1.5s infinite ease-in-out",
                                  boxShadow: "0 0 10px rgba(76, 175, 80, 0.5)",
                                }}
                              />
                            )}
                            {item.isAutoGenerated ? (
                              <>
                                <TextField
                                  select
                                  value={item.Topic || ""}
                                  onChange={(e) => {
                                    const selectedTopicName = e.target.value;
                                    const selectedTopicObj =
                                      availableTopicOptions.find(
                                        (opt) => opt.topic === selectedTopicName
                                      );
                                    handleTopicChange(
                                      item.id,
                                      selectedTopicName,
                                      selectedTopicObj
                                        ? selectedTopicObj.id
                                        : null
                                    );
                                  }}
                                  variant="outlined"
                                  size="small"
                                  sx={{ minWidth: 150 }}
                                  label={item.Topic ? "" : "Select Lesson"}
                                  disabled={disableActions}
                                >
                                  <MenuItem value="" disabled>
                                    Select Lesson
                                  </MenuItem>
                                  {availableTopicOptions
                                    .filter(
                                      (opt) =>
                                        opt.subject === item.Subject &&
                                        opt.year ===
                                          (students.find(
                                            (s) => s.Name === item.Student
                                          )?.Year || "")
                                    )
                                    .map((option) => (
                                      <MenuItem
                                        key={option.id}
                                        value={option.topic}
                                      >
                                        {option.topic}
                                      </MenuItem>
                                    ))}
                                </TextField>
                                <Typography
                                  variant="caption"
                                  sx={{
                                    background:
                                      "linear-gradient(to right, #c5cae9, #9fa8da)",
                                    color: "#283593",
                                    px: 1,
                                    py: 0.4,
                                    borderRadius: "6px",
                                    fontWeight: 600,
                                    fontSize: "0.72rem",
                                    animation: "fadeInScale 0.4s ease-out",
                                    boxShadow: "0 0 6px rgba(63,81,181,0.3)",
                                  }}
                                >
                                  Auto
                                </Typography>
                              </>
                            ) : (
                              <>
                                <Typography sx={{ fontWeight: 500 }}>
                                  {item.Topic}
                                </Typography>
                                <Typography
                                  variant="caption"
                                  sx={{
                                    background:
                                      "linear-gradient(to right, #bbdefb, #64b5f6)", // Blue

                                    color: "#6d4c41",
                                    px: 1,
                                    py: 0.4,
                                    borderRadius: "6px",
                                    fontWeight: 600,
                                    fontSize: "0.72rem",
                                    animation: "fadeInScale 0.4s ease-out",
                                    boxShadow: "0 0 6px rgba(255,213,79,0.4)",
                                    ml: 1,
                                  }}
                                >
                                  Manual
                                </Typography>
                              </>
                            )}
                          </Box>
                        </TableCell>

                        <TableCell
                          sx={{
                            textDecoration: rowStatus.startsWith("past")
                              ? "line-through"
                              : "none",
                          }}
                        >
                          {item.Day}
                        </TableCell>

                        {showSubjectColumn && (
                          <>
                            <TableCell
                              sx={{
                                textDecoration: rowStatus.startsWith("past")
                                  ? "line-through"
                                  : "none",
                              }}
                            >
                              {item.Faculty}
                            </TableCell>
                            <TableCell
                              sx={{
                                textDecoration: rowStatus.startsWith("past")
                                  ? "line-through"
                                  : "none",
                              }}
                            >
                              {item.Subject}
                            </TableCell>
                          </>
                        )}

                        <TableCell
                          sx={{
                            textDecoration: rowStatus.startsWith("past")
                              ? "line-through"
                              : "none",
                          }}
                        >
                          {item.Time}
                        </TableCell>

                        <TableCell
                          sx={{
                            textDecoration: rowStatus.startsWith("past")
                              ? "line-through"
                              : "none",
                          }}
                        >
                          {calculateDuration(item.Time)}
                        </TableCell>

                        <TableCell
                          sx={{
                            textDecoration: rowStatus.startsWith("past")
                              ? "line-through"
                              : "none",
                          }}
                        >
                          {item.monthlyFeePerClass !== "N/A"
                            ? `₹${item.monthlyFeePerClass}`
                            : "N/A"}
                        </TableCell>

                        <TableCell>
                          <Box
                            sx={{
                              display: "flex",
                              gap: 1,
                              justifyContent: "center",
                              alignItems: "center",
                            }}
                          >
                            <Tooltip title={tooltipEditTitle}>
                              <span>
                                <IconButton
                                  aria-label="edit"
                                  size="small"
                                  onClick={() => handleEditTimetable(item)}
                                  sx={{
                                    color: "#1976d2",
                                    transition: "all 0.2s ease-in-out",
                                    "&:hover": {
                                      backgroundColor:
                                        "rgba(25, 118, 210, 0.1)",
                                      transform: "scale(1.1)",
                                    },
                                    "&.Mui-disabled": {
                                      color: "#bdbdbd",
                                    },
                                  }}
                                  disabled={disableActions}
                                >
                                  <MdEdit />
                                </IconButton>
                              </span>
                            </Tooltip>

                            <Tooltip title={tooltipDeleteTitle}>
                              <span>
                                <IconButton
                                  aria-label="delete"
                                  size="small"
                                  color="error"
                                  onClick={() => handleDeleteClick(item)}
                                  sx={{
                                    transition: "all 0.2s ease-in-out",
                                    "&:hover": {
                                      backgroundColor: "rgba(211, 47, 47, 0.1)",
                                      transform: "scale(1.1)",
                                    },
                                    "&.Mui-disabled": {
                                      color: "#bdbdbd",
                                    },
                                  }}
                                  disabled={
                                    disableActions || item.isAutoGenerated
                                  }
                                >
                                  <MdDelete />
                                </IconButton>
                              </span>
                            </Tooltip>
                          </Box>
                        </TableCell>
                      </TableRow>
                    );
                  })}
                </TableBody>
               <TableFooter>
  <TableRow
    sx={{
      background: 'rgba(240, 248, 255, 0.75)', // soft blue with transparency
      backdropFilter: 'blur(4px)', // glass effect
      borderTop: '2px solid #90caf9',
      '& > td': {
        fontWeight: 600,
        fontSize: '1.1rem',
        color: '#0d47a1',
        padding: '14px 18px',
        borderBottom: 'none',
        transition: 'all 0.3s ease',
      },
      '&:hover > td': {
        backgroundColor: 'rgba(227, 242, 253, 0.4)', // subtle hover glow
      },
    }}
  >
    {/* Total Label Cell */}
    <TableCell
      colSpan={showSubjectColumn ? 7 : 5}
      align="right"
      sx={{
        background: 'linear-gradient(to right, #e3f2fd, #bbdefb)',
        borderRight: '1px solid rgba(0, 0, 0, 0.05)',
      }}
    >
      <Typography
        variant="h6"
        component="span"
        sx={{
          fontWeight: 800,
          color: '#0d47a1',
          display: 'flex',
          alignItems: 'center',
          justifyContent: 'flex-end',
          gap: 1.2,
          letterSpacing: '0.04em',
          textShadow: '0 1px 1px rgba(0,0,0,0.08)',
        }}
      >
        <MdCurrencyRupee
          style={{
            color: '#1976d2',
            fontSize: '1.6rem',
            transform: 'translateY(-1px)',
          }}
        />
        GRAND TOTAL:
      </Typography>
    </TableCell>

    {/* Total Hours */}
    <TableCell align="center">
    <Typography
  variant="h6"
  sx={{
    fontWeight: 700,
    color: '#1b5e20',
    display: 'flex',
    alignItems: 'center',
    justifyContent: 'center',
    gap: 0.5,
  }}
>
  {sumHours.toFixed(2)}
  <FaHourglassHalf
    style={{
      fontSize: '1.4rem',
      color: '#388e3c',
      marginLeft: '4px', // Ensures space between number and icon
    }}
  />
</Typography>

    </TableCell>

    {/* Total Fee */}
    <TableCell align="center">
      <Typography
  variant="h6"
  sx={{
    fontWeight: 700,
    color: '#b71c1c',
    display: 'flex',
    alignItems: 'center',
    justifyContent: 'center',
    gap: 1,
  }}
>
  <MdCurrencyRupee
    style={{
      fontSize: '1.6rem',
      color: '#b71c1c',
    }}
  />
  {sumFee.toFixed(2)}
</Typography>
    </TableCell>

    {/* Placeholder for summary or actions */}
    <TableCell align="center" sx={{ color: '#546e7a', fontStyle: 'italic' }}>
      {/* Optionally: `Classes: X` or leave empty */}
    </TableCell>
  </TableRow>
</TableFooter>

              </Table>
            </TableContainer>
          ) : (
            <Box
              sx={{
                textAlign: "center",
                p: 3,
                color: "text.secondary",
                minHeight: "200px",
                display: "flex",
                flexDirection: "column",
                alignItems: "center",
                justifyContent: "center",
              }}
            >
              <FaInfoCircle
                style={{ fontSize: "3rem", marginBottom: "15px" }}
              />
              <Typography variant="h6">No Timetables Found</Typography>
              <Typography variant="body2">
                Adjust your filters or add a new timetable.
                {autoGenerateErrorMsg && (
                  <Typography variant="body2" color="error">
                    {autoGenerateErrorMsg}
                  </Typography>
                )}
              </Typography>
            </Box>
          )}
        </Paper>
      </Slide>

      <Dialog
        open={openDeleteConfirm}
        onClose={() => setOpenDeleteConfirm(false)}
        aria-labelledby="alert-dialog-title"
        aria-describedby="alert-dialog-description"
      >
        <DialogTitle id="alert-dialog-title">{"Confirm Deletion"}</DialogTitle>
        <DialogContent>
          <DialogContentText id="alert-dialog-description">
            Are you sure you want to delete the timetable for{" "}
            <strong>{timetableToDelete?.Student}</strong> on{" "}
            <strong>{timetableToDelete?.Day}</strong> at{" "}
            <strong>{timetableToDelete?.Time}</strong>?
          </DialogContentText>
        </DialogContent>
        <DialogActions>
          <Button
            onClick={() => setOpenDeleteConfirm(false)}
            disabled={isDeleting}
          >
            Cancel
          </Button>
          <Button
            onClick={handleDeleteConfirm}
            color="error"
            autoFocus
            disabled={isDeleting}
          >
            {isDeleting ? <CircularProgress size={24} /> : "Delete"}
          </Button>
        </DialogActions>
      </Dialog>

      {/* General Snackbar for messages */}
      <Snackbar
        open={snackbarOpen}
        autoHideDuration={6000}
        onClose={handleSnackbarClose}
        anchorOrigin={{ vertical: "top", horizontal: "right" }}
      >
        <MuiAlert
          onClose={handleSnackbarClose}
          severity={snackbarSeverity}
          sx={{ width: "100%" }}
        >
          {snackbarMessage}
        </MuiAlert>
      </Snackbar>
    </Box>
  );
};

export default TimetablePage;
