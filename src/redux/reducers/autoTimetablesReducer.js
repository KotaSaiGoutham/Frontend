
import {
  SAVE_AUTOGENERATED_TIMETABLES_REQUEST,
  SAVE_AUTOGENERATED_TIMETABLES_SUCCESS,
  SAVE_AUTOGENERATED_TIMETABLES_FAILURE,
  FETCH_AUTOTIMETABLES_REQUEST,
  FETCH_AUTOTIMETABLES_SUCCESS,
  FETCH_AUTOTIMETABLES_FAILURE,
  UPDATE_AUTOTIMETABLE_REQUEST,
  UPDATE_AUTOTIMETABLE_SUCCESS,
  UPDATE_AUTOTIMETABLE_FAILURE,
  DELETE_AUTOTIMETABLE_REQUEST,
  DELETE_AUTOTIMETABLE_SUCCESS,
  DELETE_AUTOTIMETABLE_FAILURE,
   UPDATE_AUTO_TIMETABLE_TOPIC_REQUEST,
  UPDATE_AUTO_TIMETABLE_TOPIC_SUCCESS,
  UPDATE_AUTO_TIMETABLE_TOPIC_FAILURE  
} from "../types";

// --- NEW Auto-Timetable Reducer ---
const initialAutoTimetablesState = {
  timetables: [], // This will hold auto-generated timetables
  loading: false,
  error: null,
  hasSavedToday: false, // To track if save occurred successfully for today
};

 const autoTimetablesReducer = (state = initialAutoTimetablesState, action) => {
  switch (action.type) {
    case SAVE_AUTOGENERATED_TIMETABLES_REQUEST:
    case FETCH_AUTOTIMETABLES_REQUEST:
    case UPDATE_AUTOTIMETABLE_REQUEST:
    case DELETE_AUTOTIMETABLE_REQUEST:
      return { ...state, loading: true, error: null };

    case SAVE_AUTOGENERATED_TIMETABLES_SUCCESS:
      // After saving, the fetchAutoTimetablesForToday will update 'timetables'
      return { ...state, loading: false, error: null, hasSavedToday: true };

    case FETCH_AUTOTIMETABLES_SUCCESS:
      return {
        ...state,
        loading: false,
        timetables: action.payload,
        error: null,
        // Set hasSavedToday based on whether data was fetched successfully for today
        hasSavedToday: action.payload && action.payload.length > 0,
      };

    case UPDATE_AUTOTIMETABLE_SUCCESS:
      return {
        ...state,
        loading: false,
        timetables: state.timetables.map((tt) =>
          tt.id === action.payload.id ? action.payload : tt
        ),
        error: null,
      };

    case DELETE_AUTOTIMETABLE_SUCCESS:
      return {
        ...state,
        loading: false,
        timetables: state.timetables.filter(
          (tt) => tt.id !== action.payload
        ),
        error: null,
      };

    case SAVE_AUTOGENERATED_TIMETABLES_FAILURE:
    case FETCH_AUTOTIMETABLES_FAILURE:
    case UPDATE_AUTOTIMETABLE_FAILURE:
    case DELETE_AUTOTIMETABLE_FAILURE:
      return { ...state, loading: false, error: action.payload.error };
 case UPDATE_AUTO_TIMETABLE_TOPIC_REQUEST:
            return {
                ...state,
                loading: true,
                error: null,
            };
        case UPDATE_AUTO_TIMETABLE_TOPIC_SUCCESS:
            const { itemId, updatedData } = action.payload;
            return {
                ...state,
                loading: false,
                autoTimetables: state.autoTimetables.map(item =>
                    item.id === itemId ? { ...item, ...updatedData } : item
                ),
            };
        case UPDATE_AUTO_TIMETABLE_TOPIC_FAILURE:
            return {
                ...state,
                loading: false,
                error: action.payload,
            };
    default:
      return state;
  }
};
export default autoTimetablesReducer

// Combine your reducers (assuming you have a rootReducer)
// import { combineReducers } from 'redux';
// export default combineReducers({
//   auth: authReducer,
//   students: studentsReducer,
//   classes: classesReducer, // Manual timetables
//   autoTimetables: autoTimetablesReducer, // NEW: Auto-generated timetables
//   // ... other reducers
// });